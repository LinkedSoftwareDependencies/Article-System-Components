<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title property="foaf:name schema:name">Components.js: Semantic Dependency Injection</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="citation_title" content="Components.js: Semantic Dependency Injection">
  <meta name="citation_author" content="Ruben Taelman" />
  <meta name="citation_author" content="Joachim Van Herwegen" />
  <meta name="citation_author" content="Miel Vander Sande" />
  <meta name="citation_author" content="Ruben Verborgh" />
  
  <meta name="citation_publication_date" content="2021/11/12" />
</head>

<body prefix="dctypes: http://purl.org/dc/dcmitype/ pimspace: http://www.w3.org/ns/pim/space# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# lsc: http://linkedscience.org/lsc/ns#" typeof="schema:CreativeWork sioc:Post prov:Entity lsc:Research">
  <header>
  <h1 id="componentsjs-semantic-dependency-injection">Components.js: Semantic Dependency Injection</h1>

  <ul id="authors">
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="http://www.rubensworks.net/" typeof="foaf:Person schema:Person" resource="http://www.rubensworks.net/#me">Ruben Taelman</a><a href="#idlab"><sup>1</sup></a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="#" typeof="foaf:Person schema:Person" resource="https://data.verborgh.org/people/joachim_van_herwegen">Joachim Van Herwegen</a><a href="#idlab"><sup>1</sup></a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="#" typeof="foaf:Person schema:Person" resource="https://data.verborgh.org/people/miel_vander_sande">Miel Vander Sande</a><a href="#meemoo"><sup>2</sup></a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://ruben.verborgh.org/" typeof="foaf:Person schema:Person" resource="https://ruben.verborgh.org/profile/#me">Ruben Verborgh</a><a href="#idlab"><sup>1</sup></a></li>
  </ul>

  <ul id="affiliations">
    <li id="idlab"><sup>1</sup>IDLab,
          Department of Electronics and Information Systems,
          Ghent University – imec
          <br />E-mail: ruben.taelman@ugent.be</li>
    <li id="meemoo"><sup>2</sup>meemoo, Flemish Institute for Archives</li>
  </ul>

</header>

<div id="content">
  <section id="abstract" inlist="" rel="schema:hasPart" resource="#abstract">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Abstract</h2>
      <!-- Context      -->
      <p>A common practice within object-oriented software
is using <em>composition</em> to realize complex object behavior
in a reusable way.
Such compositions can be managed by <em>Dependency Injection (DI)</em>,
a popular technique in which components only depend on minimal interfaces
and have their concrete dependencies passed into them.
Instead of requiring program code,
this separation enables describing the desired instantiations
in declarative configuration files,
such that objects can be wired together automatically at runtime.
Configurations for existing DI frameworks typically only have local semantics,
which limits their usage in other contexts.
<!-- Need         -->
Yet some cases require configurations outside of their local scope,
such as for the reproducibility of experiments, static program analysis, and semantic workflows.
As such, there is a need for globally interoperable, addressable, and discoverable configurations,
which can be achieved by leveraging Linked Data.
<!-- Task         -->
We created <em>Components.js</em> as
an open-source semantic DI framework for TypeScript and JavaScript applications,
providing global semantics via Linked Data-based configuration files.
<!-- Object       -->
In this article, we report on the Components.js framework
by explaining its architecture and configuration,
and discuss its impact by mentioning where and how applications use it.
<!-- Findings     -->
We show that Components.js is a stable framework that has seen significant uptake during the last couple of years.
<!-- Conclusion   -->
We recommend it for software projects that require
high flexibility,
configuration without code changes,
sharing configurations with others,
or applying these configurations in other contexts such as experimentation or static program analysis.
<!-- Perspectives -->
We anticipate that Components.js will continue driving concrete research and development projects
that require high degrees of customization to facilitate experimentation and testing,
including the Comunica query engine and the Community Solid Server for decentralized data publication.</p>

    </div>
</section>


<div class="double-column">

<main>
  <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Introduction</h2>

          <p>Object-oriented (OO) programming is a highly popular paradigm within the domain of software engineering.
Considering <em>objects</em> containing data and logic as primary software elements
makes it easy for developers to understand software,
as it makes software resemble real-world mechanisms with interacting physical objects.
Most OO languages enable object composition <span class="references">[<a href="#ref-1">1</a>]</span>,
a flexible pattern for managing object object relationships,
where objects can be contained within other objects.</p>

          <p>A popular technique to manage the composition of objects is called <a property="schema:citation http://purl.org/spar/cito/cites" href="https://martinfowler.com/articles/injection.html"><em>Dependency Injection</em> (DI)</a> <span class="references">[<a href="#ref-2">2</a>]</span>.
It enables objects to <em>ask</em> for the interfaces it requires, rather than <em>retrieving</em> or <em>instantiating</em> objects implementing these interfaces itself.
A DI framework is then responsible for <em>instantiating</em> and <em>injecting</em> the necessary dependencies into these objects.
This technique allows objects to be very loosely coupled,
as they only depend on each other via a minimal and generic interface,
without depending on concrete implementations of such interfaces.
In order to link these interfaces to concrete implementations,
a generic DI framework can provide specific implementations where needed based on some external configuration.
Since objects only communicate by strict interfaces,
and specific implementations are derived from an external configuration,
the specific wiring of a software application is decoupled from the application’s main implementation.
This allows the wiring to be altered afterwards by only modifying this configuration,
which makes the application more flexible.</p>

          <p>Configurations for existing DI frameworks
are either defined directly within a programming language,
or are defined declaratively within text files with a domain-specific language using syntaxes such as JSON and XML.
The latter type of configuration files is better suited for use cases where no changes can be made to existing code
(e.g., in the case of pre-compiled languages),
when the creators of these configuration files have no programming knowledge,
or when configuration files are created automatically from an external tool
(e.g., a visual drag-and-drop interface).
Such declarative configuration files typically have only <em>local</em> semantics,
which means that they are usually only usable within the DI framework for which they were created, and for the current application only.
With the power of <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/DesignIssues/LinkedData.html">Linked Data</a> <span class="references">[<a href="#ref-3">3</a>]</span> and the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www-sop.inria.fr/acacia/cours/essi2006/Scientific%20American_%20Feature%20Article_%20The%20Semantic%20Web_%20May%202001.pdf">Semantic Web</a> <span class="references">[<a href="#ref-4">4</a>]</span> in mind,
these configurations could move <em>beyond</em> their local scope,
and make them globally <em>interoperable</em>, <em>addressable</em>, and <em>discoverable</em>.</p>

          <p>To this end, we present <em>Components.js</em>,
a semantic DI framework for TypeScript and JavaScript applications
that gives global semantics to software configurations, hence surpassing existing dependency injection frameworks.
Components.js thereby enables highly modular applications to be built that are dynamically wired based on semantic configuration files.
The framework is <a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/LinkedSoftwareDependencies/Components.js">open-source</a> <span class="references">[<a href="#ref-5">5</a>]</span>,
is available on <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.npmjs.com/package/componentsjs">npm</a> <span class="references">[<a href="#ref-6">6</a>]</span>,
and has extensive <a property="schema:citation http://purl.org/spar/cito/cites" href="https://componentsjs.readthedocs.io/">documentation</a> <span class="references">[<a href="#ref-7">7</a>]</span>.
Furthermore, it is being actively used as core technology within popular tools such as
the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/solid/community-server/">Community Solid Server</a> <span class="references">[<a href="#ref-8">8</a>]</span> and <a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.github.io/Article-ISWC2018-Resource/">Comunica</a> <span class="references">[<a href="#ref-9">9</a>]</span>.
Within Components.js,
software configurations and modules are described as Linked Data using
the <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://linkedsoftwaredependencies.org/articles/describing-experiments/"><em>Object-Oriented Components vocabulary</em></a> <span class="references">[<a href="#ref-10">10</a>]</span>
and the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://linkedsoftwaredependencies.org/vocabularies/object-mapping"><em>Object Mapping vocabulary</em></a> <span class="references">[<a href="#ref-11">11</a>]</span>.
By publishing such descriptions,
the composition of software (and parts thereof) can be <em>unambiguously identified</em> by IRIs and 
retrieved through <em>dereferencing</em>.
Components.js automatically <em>instantiates</em> such software configurations, including resolving the necessary dependencies.
As such, this (de)referenceability of software configurations by IRI could be beneficial in use cases such as:</p>

          <dl>
            <dt>Experimental research</dt>
            <dd>Providing the full provenance trail of used software configurations to produce experimental results for improving reproducibility.</dd>
            <dt>Static program analysis</dt>
            <dd>Discovering conflicts or compatibility issues of different classes within software using RDF tools such as SPARQL query engines and reasoners.</dd>
            <dt>Semantic workflows</dt>
            <dd>Automatic wiring of software using RDF tools to optimally address a specific need.</dd>
          </dl>

          <p>We consider this article an extension of our previous work involving <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://linkedsoftwaredependencies.org/articles/describing-experiments/">describing software as Linked Data</a> <span class="references">[<a href="#ref-10">10</a>]</span>.
Concretely, the contributions of this work are:</p>

          <ul>
            <li>the Components.js dependency injection framework and its architecture;</li>
            <li>the Components-Generator.js tool for generating component descriptions for TypeScript projects;</li>
            <li>the Object-Oriented Components and Object Mapping vocabularies; and</li>
            <li>the Linked Software Dependencies (LSD) service that makes npm packages dereferenceable.</li>
          </ul>

          <p>While Components.js can aid in the reproduction of experiments as one possible use case,
we consider full reproducibility of experiments out of scope for this work.
Instead, to enable full replication of experiments,
we refer to tools such as <a property="schema:citation http://purl.org/spar/cito/cites" href="https://nixos.org/">NixOS</a> <span class="references">[<a href="#ref-12">12</a>]</span> that can describe full experimental environments,
where Components.js can offer more granular software configuration descriptions.</p>

          <p>In this article, we introduce the Components.js framework as follows.
In the next section (<a href="#related-work">Section 2</a>), we discuss the related work.
Next, in <a href="#configs">Section 3</a> we explain the declarative configuration files of Components.js,
followed by an architectural overview of the framework itself in <a href="#system">Section 4</a>.
Then, in <a href="#usage">Section 5</a>, we mention some applications where Components.js is being used.
Finally, we conclude in <a href="#conclusions">Section 6</a>.</p>

        </div>
</section>

  <section id="related-work" inlist="" rel="schema:hasPart" resource="#related-work">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Related Work</h2>

          <h3 id="related-work-di">Dependency Injection</h3>

          <p><strong>Inversion of Control</strong></p>

          <p><a property="schema:citation http://purl.org/spar/cito/cites" href="https://martinfowler.com/articles/injection.html">Inversion of Control (IoC)</a> <span class="references">[<a href="#ref-2">2</a>]</span> is a general principle within software engineering
that inverts the usual flow of control within software architectures.
This is mostly done to reduce coupling between software components, and make the overall architecture more modular and extensible.
On the one hand, traditional procedural programming gives the developer direct control of the flow of logic, where code directly invokes other code.
IoC on the other hand implies the use of a framework that manages this flow,
and allows custom code –that is supplied by the developer–
to be invoked when the frameworks deems it necessary.
This concept is typically referred to as <em>“The Hollywood Principle: Don’t call us, we’ll call you”</em>.</p>

          <p>A specific technique to achieve IoC is <a property="schema:citation http://purl.org/spar/cito/cites" href="https://martinfowler.com/articles/injection.html"><em>Dependency Injection</em> (DI)</a> <span class="references">[<a href="#ref-2">2</a>]</span>,
where the framework calls constructors and methods with the right parameters.
As mentioned before, DI enables relationships between objects by allowing objects to <em>ask</em> for other objects, rather than actively getting them itself.
These composed objects are tied to each other only by a lightweight interface,
where different implementations may be possible for each interface.
Using a DI framework, specific implementations for such interfaces can be configured,
after which they can be instantiated into objects,
and are injected into each other using the DI framework’s <em>assembler</em> to complete the wiring of the software application.</p>

          <p>The configuration of such a wiring of objects
can either be done in code, or via external configuration files.
The main motivations for configurations are the strict boundaries between configuration and logic,
enabling non-developers to configure the code,
and taking away the need to recompile the code for pre-compiled languages.
However, when dependencies are defined based on some logic such as external conditions,
configuration via code may be better suited,
as this can become too complex to define in declarative configuration files.</p>

          <p><strong>Forms of Injection</strong></p>

          <p>In practice, three main forms of DI exist through which dependencies can be injected into an object:</p>

          <dl>
            <dt>Constructor injection</dt>
            <dd>Dependency objects are passed via a class constructor.</dd>
            <dt>Setter injection</dt>
            <dd>Dependencies are passed to an object by invoking setter methods.</dd>
            <dt>Interface injection</dt>
            <dd>The interface of dependencies expose a method that, when invoked, injects this dependency into an object that is passed to it. Such passed objects will typically be a setter method for this.</dd>
          </dl>

          <p>Constructor injection is the simplest and most popular form.
It requires all dependencies to be wired at construction time,
which usually leads to immutable wiring.
Setter injection is more flexible as wiring can be changed afterwards,
but could lead to problems where not all dependencies have been fully configured yet.
Interface injection is more complex, and is mainly useful if bidirectional links between dependencies and dependents need to be configured.</p>

          <p><strong>Advantages and Disadvantages</strong></p>

          <p>To end this section, we summarize the main <a href="https://betterprogramming.pub/the-6-benefits-of-dependency-injection-7802b207ec69">advantages</a>
and <a href="https://www.professionalqa.com/dependency-injection">disadvantages</a> of DI.</p>

          <p>Advantages:</p>

          <ul>
            <li>Classes are loosely coupled, which leads to <strong>lower maintenance</strong> effort.</li>
            <li>Loose coupling also leads to better <strong>testability</strong>, as dependencies with lightweight interfaces can easily be mocked.</li>
            <li>Classes have a single responsibility, which leads to <strong>better understandable</strong> code.</li>
            <li>Applications are more <strong>flexible</strong>, as they can be wired differently by changing a configuration file.</li>
            <li>Applications are more <strong>extensible</strong>, as different interface implementations can be created, and swapped in or out easily.</li>
            <li>Since classes are coded against interfaces of dependencies, they lead to more <strong>independent</strong> code, which is beneficial in large teams that work in parallel.</li>
          </ul>

          <p>Disadvantages:</p>

          <ul>
            <li>Defining the wiring of an application via <strong>configurations can be complex</strong>, so good defaults must be available.</li>
            <li>Logic <strong>flow is harder to follow</strong> when debugging, which leads to the need of good documentation.</li>
            <li>DI frameworks can lead to <strong>overhead</strong> in terms of understandability, execution time and software size.</li>
          </ul>

          <h3 id="related-work-software-description">Semantic Software Description</h3>

          <p>Configuration-based DI frameworks make use of some form of software description.
Therefore, we introduce the related work around semantic software descriptions.</p>

          <p>Software can be described on several levels of granularity,
going from a high-level package overview to a low-level description of the actual code.
The Software Ontology (SWO) <span class="references">[<a href="#ref-13">13</a>]</span> and <a property="schema:citation http://purl.org/spar/cito/cites" href="http://usefulinc.com/ns/doap">Description of a Project (DOAP)</a> <span class="references">[<a href="#ref-14">14</a>]</span> ontology focus on the high-level management of software development,
enabling the description of tools, resources, contributors and tasks. 
At a slightly lower level, SWO includes interfaces, algorithms, versions, and the associated provenance data, but does not reach the level of detail to describe operational code.</p>

          <p>Ontologies that describe software configuration from a research workflow perspective are <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1145/2814864.2814882"><a href="http://svn.aksw.org/papers/2015/SEMANTICS_LDWPO/public.pdf">LODFlow</a></span> <span class="references">[<a href="#ref-15">15</a>]</span>, <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2015.01.003"><a href="https://doi.org/10.1016/j.websem.2015.01.003">Workflow-Centric Research Objects</a></span> <span class="references">[<a href="#ref-16">16</a>]</span> with the <cite><a href="https://w3id.org/ro/">Wf4Ever Research Object Model</a></cite> and the <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1109/escience.2014.47"><a href="http://www.ifs.tuwien.ac.at/%7Emayer/publications/pdf/may_escience14.pdf">Ontologies for Describing the Context of Scientific Experiment Processes</a></span> <span class="references">[<a href="#ref-17">17</a>]</span> with the <cite><a href="http://www.timbusproject.net/portal/publications/ontologies/">TIMBUS Context Model</a></cite> to compliment the Research Objects model. 
From a more generic perspective, there exist the <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://www.w3.org/TR/prov-o/">PROV Ontology</a> <span class="references">[<a href="#ref-18">18</a>]</span>, the OPMW-PROV Ontology <span class="references">[<a href="#ref-19">19</a>]</span>, and the <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="http://rdf-vocabulary.ddialliance.org/discovery.html">DDI-RDF Discovery Vocabulary</a> <span class="references">[<a href="#ref-20">20</a>]</span>.
However, these efforts can only cover (parts of) the connection between research and software, which is insufficient for dependency injection.
Such descriptions are moreover interpretive in that any given tool is subject to having multiple descriptions by different users.
In contrast to the human-driven descriptions, our work both enables and accelerates the generation of machine-driven Linked Data descriptions of software modules, their components, as well as their configurations to be uniformly created.
Consequently, this makes it possible to accurately describe and instantiate software experiments that can be reused and compared with unambiguously.</p>

          <p>Much more low-level and exact is the Core Software Ontology (CSO) <span class="references">[<a href="#ref-21">21</a>]</span>,
which provides a foundational vocabulary that is designed for extensibility.
This includes the distinctive concepts to describe software as code, software as object to computational hardware, and software as a running computational activity,
but also Interfaces, Classes, Methods, the relationships between them, and workflow information on their invocation.
Its extension, the Core Ontology of Software Components (COSC), moves closer to the topic of this article by describing interfaces and protocols of objects.
Similar in scope is the Software Engineering Ontology Network (SEON) <span class="references">[<a href="#ref-22">22</a>]</span>, which consolidates multiple ontologies for the Software Engineering field.
It includes a higher Core and Foundational layer, as well as multiple domain-specific ontologies.
Of particular interest is their Software Ontology (SwO) that captures the different artifacts in software.
More recently, the GraphGen4Code toolkit <span class="references">[<a href="#ref-23">23</a>]</span> has been introduced,
which provides an ontology to capture code semantics to represent classes, functions and methods.
In general, these ontologies (or suites) view software from a <q>network of communicating concepts</q> perspective.
This allows for exhaustive descriptions of complex software systems, but is not suited for describing class instances or aspects of modular programming (e.g., package dependencies).
As such, the vocabularies that we introduced do not make use of these existing ontologies,
but they do make use of parts of them where possible.</p>

          <h3 id="related-work-di-frameworks">Dependency Injection Frameworks</h3>

          <p>The large spectrum of existing dependency injection frameworks indicates a high demand for such systems.
Java likely contains the largest collection of dependency injection frameworks.
Much of this stems from the strict typing,
which makes it difficult to create mock objects when required for testing
if the dependencies are nested in the implementation.</p>

          <p>One of the biggest Java frameworks is <a property="schema:citation http://purl.org/spar/cito/cites" href="https://spring.io/">Spring</a> <span class="references">[<a href="#ref-24">24</a>]</span>,
which amongst many things, also provides dependency injection.
That is one of its advantages though:
many projects already use Spring for other reasons,
reducing the jump required to add the dependency injection framework.
It supports two ways to do the injection.
The first one is through an external XML configuration file
which defines all the classes and how they are linked together.
The other one is with annotations in the actual code
that define how the interlinking of classes should work.
Google’s <a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/google/guice">Guice</a> <span class="references">[<a href="#ref-25">25</a>]</span> is a more lightweight alternative to Spring;
<a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/google/dagger">Dagger</a> <span class="references">[<a href="#ref-26">26</a>]</span> was created to be even more lightweight than Guice.</p>

          <p>In JavaScript, 
dependency injection frameworks tend to be less common because of its flexible nature.
However, with the increasing popularity of TypeScript –which provides strict typings for JavaScript–,
the need for dependency injection is increasing.
Still, multiple frameworks are available, such as <a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/young-steveo/bottlejs">BottleJS</a> <span class="references">[<a href="#ref-27">27</a>]</span>, <a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/cujojs/wire">Wire</a> <span class="references">[<a href="#ref-28">28</a>]</span>, and <a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/jaredhanson/electrolyte">Electrolyte</a> <span class="references">[<a href="#ref-29">29</a>]</span>, all backed by rather small communities.
One of the biggest ones, <a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/inversify/InversifyJS">InversifyJS</a> <span class="references">[<a href="#ref-30">30</a>]</span>,
uses annotations similar to Java frameworks to define possible injections.
Unlike standard JavaScript,
it requires the developer to define interfaces and types via TypeScript,
thereby allowing it to make use of this extra information to correctly handle the linking.
Like Guice, it also has a bindings file to link classes to interfaces.</p>

          <p>Components.js differs from the aforementioned frameworks on different aspects.
First, Components.js decouples the dependency injection layer from the software implementation via <strong>separate configuration files</strong>,
while the other JavaScript DI frameworks use code-based configuration and thereby have a stronger coupling of these layers.
Is is thereby more similar to the Java-based DI frameworks that tend to rely more on external configuration files.
This is the primary reason why we opted to create a new framework, instead of extending an existing one.
Second, Components.js is the only framework that makes use of <strong>RDF-based configuration files</strong>,
which makes these configurations globally <em>interoperable</em>, <em>addressable</em>, and <em>discoverable</em>.
Third, regarding the form of dependency injection, Components.js makes use of <strong>constructor injection</strong>,
just like all other discussed frameworks.
Only the Spring also provides the option to make use of the other forms of injection,
but constructor injection is the most popular option.</p>

          <h3 id="related-work-js-runtime-environments">JavaScript Runtime Environments</h3>

          <p>The most popular runtime environment for JavaScript is <a property="schema:citation http://purl.org/spar/cito/cites" href="https://nodejs.org/en/">Node.js</a> <span class="references">[<a href="#ref-31">31</a>]</span>,
which allows JavaScript code to be executed outside of a Web browser.
Node.js is based on the highly performant <a property="schema:citation http://purl.org/spar/cito/cites" href="https://v8.dev/">V8 engine</a> <span class="references">[<a href="#ref-32">32</a>]</span> that is also used within the Chrome browser. 
Even though Node.js can not directly execute TypeScript code,
TypeScript code can be transpiled to JavaScript so that it can be executed in Node.js.
Node.js makes use of the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.npmjs.com/">npm</a> <span class="references">[<a href="#ref-33">33</a>]</span> package manager for distributing and installing third-party packages (over 1.3 million at the time of writing).
Using a <code>package.json</code> file, all dependencies of a module can be defined together with their version range, which are resolved from npm at install time.</p>

          <p><a property="schema:citation http://purl.org/spar/cito/cites" href="https://deno.land/">Deno</a> <span class="references">[<a href="#ref-34">34</a>]</span> is a relatively new runtime environment for JavaScript that aims to become a modern replacement for Node.js.
It is also based on the V8 engine, but it allows both JavaScript <em>and</em> TypeScript to be executed without prior transpilation.
Furthermore, there is a significant difference in the way Deno handles dependencies compared to Node.js.
Code written for Node.js can only refer to dependencies by a name, and requires a package manager such as npm to bind it to a concrete package and version.
Deno avoids this decoupling by allowing code to directly refer to dependencies based on URLs that can include version ranges.</p>

          <p>For the remainder of this article, we will assume the usage of the Node.js runtime.
This is because Components.js Node.js is still predominantly used at the time of writing.
Nevertheless, since Deno’s philosophy regarding dereferenceable modules is compatible with the dereferenceability of Components.js configurations,
we will consider support for it in the future.</p>

        </div>
</section>

  <section id="configs" inlist="" rel="schema:hasPart" resource="#configs">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Declarative Configurations</h2>

          <p>Components.js depends on two levels of configuration for enabling the wiring of software components.
The first level is the creation of <em>components</em> files,
which are the semantic representation of component (or class) constructors,
and can usually be automatically generated.
The second level is the creation of <em>configuration</em> files,
which represent the actual instantiation of components
based on the generated components files.</p>

          <p>In this section, we discuss the two main vocabularies that are used within these component files,
and show how configuration files can refer to them for instantiation.
Next, we explain how URLs can be minted for software components, so that they become fully dereferenceable.
Finally, we explain how these component files can be generated automatically from existing TypeScript code.</p>

          <h3 id="object-oriented-components-vocabulary">Object-Oriented Components Vocabulary</h3>

          <p>Components.js distinguishes between three main concepts:</p>

          <dl>
            <dt>Module</dt>
            <dd>a software package containing zero or more components. For example, this is equivalent to a module within Node.js.</dd>
            <dt>Component</dt>
            <dd>a class that can be instantiated by creating a new instance of that type with zero or more parameter values. Parameters are defined by the class constructor.</dd>
            <dt>Configuration</dt>
            <dd>a semantic representation of an instantiation of a component into an object instance based on parameters.</dd>
          </dl>

          <p>These concepts are described in the programming language independent <a href="https://linkedsoftwaredependencies.org/vocabularies/object-oriented"><em>Object-Oriented Components vocabulary (OO)</em></a> <span class="references">[<a href="#ref-10">10</a>]</span>.
This vocabulary enables software components to be instantiated based on certain parameters,
analog to constructor arguments in object-oriented programming.
This is interpreted in the broad sense: only <em>classes</em>, <em>objects</em> and <em>constructor parameters</em> are considered.
An overview is given in <a href="#voc-oo-diagram">Fig. 1</a>.</p>

          <figure id="voc-oo-diagram">
<img src="img/voc-oo-diagram.svg" alt="[description diagram]" />
<figcaption>
              <p><span class="label">Fig. 1:</span> Classes and properties in the <a href="https://linkedsoftwaredependencies.org/vocabularies/object-oriented"><em>Object-Oriented Components vocabulary (OO)</em></a>, with as prefix <code>oo</code>.</p>
            </figcaption>
</figure>

          <p>A module is considered a collection of components.
Within object-oriented languages, this can correspond to for example a software library or an application.
A component is typed as <code>oo:Component</code>, which is a <em>subclass</em> of <code>rdfs:Class</code>.
The parameters to construct the component can therefore be defined as a property having that component as its domain.</p>

          <p>Note that the vocabulary does not contain an <em>interface</em> class,
because this notion does not exist in JavaScript,
and it can exist in TypeScript code but, only before transpilation to JavaScript.
Instead, we only define <code>oo:AbstractClass</code>,
as both abstract classes and interfaces can be considered equivalent at the level of dependency injection.</p>

          <figure id="module-oo" class="listing">
<pre><code>{
</code><code>  &quot;@context&quot;: [
</code><code>    &quot;https://linkedsoftwaredependencies.org/bundles/npm/componentsjs/
</code><code>      ^4.0.0/components/context.jsonld&quot;,
</code><code>    { &quot;ex&quot;: &quot;http://example.org/&quot; }
</code><code>  ],
</code><code>  &quot;@id&quot;: &quot;ex:MyModule&quot;,
</code><code>  &quot;@type&quot;: &quot;Module&quot;,
</code><code>  &quot;requireName&quot;: &quot;my-module&quot;,
</code><code>  &quot;components&quot;: [
</code><code>    {
</code><code>      &quot;@id&quot;: &quot;ex:MyModule/MyComponent&quot;,
</code><code>      &quot;@type&quot;: &quot;Class&quot;,
</code><code>      &quot;requireElement&quot;: &quot;MyComponent&quot;,
</code><code>      &quot;parameters&quot;: [
</code><code>        {
</code><code>          &quot;@id&quot;: &quot;ex:MyModule/MyComponent#name&quot;,
</code><code>          &quot;unique&quot;: true,
</code><code>          &quot;range&quot;: &quot;xsd:string&quot;
</code><code>        }
</code><code>      ]
</code><code>    }
</code><code>  ]
</code><code>}</code></pre>
<figcaption>
              <p><span class="label">Listing 1:</span> A description of a module <code>ex:MyModule</code> with a single component using the JSON-LD serialization,
compacted with the <code>https:/​/​linkedsoftwaredependencies.org/bundles/npm/componentsjs/^4.0.0/components/context.jsonld</code> context.</p>
            </figcaption>
</figure>

          <p>We illustrate the usage of this vocabulary with an example in <a href="#module-oo">Listing 1</a> using the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/json-ld/">JSON-LD</a> <span class="references">[<a href="#ref-35">35</a>]</span> serialization.
This listing shows the definition of a new module (<code>oo:Module</code>) with compact IRI <code>ex:MyModule</code>.
The name of the module is set with the compact IRI <code>requireName</code>, which expands to <code>doap:name</code> from the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/ewilderj/doap/wiki">Description of a Project (DOAP) vocabulary</a> <span class="references">[<a href="#ref-36">36</a>]</span>.
Furthermore, our module contains a single class component (<code>oo:Class</code>) with compact IRI <code>ex:MyModule/MyComponent</code>.
Since this is a class component (subclass of <code>oo:Component</code>), this means that this component is instantiatable based on parameters.
Each component can refer to its path within a module using the <code>oo:componentPath</code> predicate (compacted as <code>requireElement</code>).
Finally, our single component has a parameter (<code>oo:Parameter</code>) with compact IRI <code>ex:MyModule/MyComponent#name</code>
that can be set when instantiating this component.</p>

          <p>Since components and parameters are defined as RDFS vocabulary,
we can instantiate components easily using the <code>rdf:type</code> predicate,
and by using parameters as predicates on such new instances, as shown in <a href="#instance-oo">Listing 2</a>.
Instead of passing literals as values to parameters, it is also possible to pass <em>other component instances</em> as values,
thereby allowing nested component instantiations to be defined.</p>

          <figure id="instance-oo" class="listing">
<pre><code>{
</code><code>  &quot;@context&quot;: [
</code><code>    &quot;https://linkedsoftwaredependencies.org/bundles/npm/componentsjs/
</code><code>      ^4.0.0/components/context.jsonld&quot;,
</code><code>    { &quot;ex&quot;: &quot;http://example.org/&quot; }
</code><code>  ],
</code><code>  &quot;@type&quot;: &quot;ex:MyModule/MyComponent&quot;,
</code><code>  &quot;ex:MyModule/MyComponent#name&quot;: &quot;Some name&quot;
</code><code>}</code></pre>
<figcaption>
              <p><span class="label">Listing 2:</span> Instantiation of <code>ex:MyModule/MyComponent</code> using a value for the parameter <code>ex:MyModule/MyComponent#name</code>.</p>
            </figcaption>
</figure>

          <h3 id="object-mapping-vocabulary">Object Mapping Vocabulary</h3>

          <p>As shown in the previous section, the OO vocabulary allows modules, components, and parameters to be defined,
so that instances of components can be declared.
However, this vocabulary only defines parameter values for component instances,
but it does not define how these parameter values are used to invoke the constructor of this component.
To enable this, we introduce the accompanying <a property="schema:citation http://purl.org/spar/cito/cites" href="https://linkedsoftwaredependencies.org/vocabularies/object-mapping"><em>Object Mapping vocabulary (OM)</em></a> <span class="references">[<a href="#ref-11">11</a>]</span>.
<a href="#voc-om-diagram">Fig. 2</a> shows an overview of all its classes and predicates.</p>

          <figure id="voc-om-diagram">
<img src="img/voc-om-diagram.svg" alt="[Object Mapping vocabulary diagram]" />
<figcaption>
              <p><span class="label">Fig. 2:</span> Classes and properties in the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://linkedsoftwaredependencies.org/vocabularies/object-mapping"><em>Object Mapping</em> vocabulary</a> <span class="references">[<a href="#ref-11">11</a>]</span>, with as prefix <code>om</code>.</p>
            </figcaption>
</figure>

          <p>The OM vocabulary makes use of the <code>oo:constructorArguments</code> predicate for the domain <code>oo:Class</code>,
and thereby builds upon the OO vocabulary via the <code>oo:constructorArguments</code> extension point to define the class constructor’s behaviour.
Concretely, this new vocabulary defines a mapping between the component parameters as defined using the OO vocabulary,
and the raw objects that are passed into the constructor during instantiation.</p>

          <p>In essence, this vocabulary enables an (RDF) list of <code>om:ObjectMapping</code>’s to be passed to the <code>oo:constructorArguments</code> of an <code>oo:Class</code>.
An <code>om:ObjectMapping</code> represents an object containing zero or more key-value pairs, which are represented by <code>om:ObjectMappingEntry</code>.
<code>om:ArrayMapping</code> is a special type of <code>om:ObjectMapping</code> that represents an array, where its elements can be other <code>om:ObjectMapping</code>’s.</p>

          <figure id="module-om" class="listing">
<pre><code>{
</code><code>  &quot;@context&quot;: [
</code><code>    &quot;https://linkedsoftwaredependencies.org/bundles/npm/componentsjs/
</code><code>      ^4.0.0/components/context.jsonld&quot;,
</code><code>    { &quot;ex&quot;: &quot;http://example.org/&quot; }
</code><code>  ],
</code><code>  &quot;@id&quot;: &quot;ex:MyModule&quot;,
</code><code>  &quot;@type&quot;: &quot;Module&quot;,
</code><code>  &quot;requireName&quot;: &quot;my-module&quot;,
</code><code>  &quot;components&quot;: [
</code><code>    {
</code><code>      &quot;@id&quot;: &quot;ex:MyModule/MyComponent&quot;,
</code><code>      &quot;@type&quot;: &quot;Class&quot;,
</code><code>      &quot;requireElement&quot;: &quot;MyComponent&quot;,
</code><code>      &quot;parameters&quot;: [
</code><code>        {
</code><code>          &quot;@id&quot;: &quot;ex:MyModule/MyComponent#name&quot;,
</code><code>          &quot;unique&quot;: true,
</code><code>          &quot;range&quot;: &quot;xsd:string&quot;
</code><code>        }
</code><code>      ]
</code><code>    }
</code><code>  ],
</code><code>  &quot;constructorArguments&quot;: [
</code><code>    {
</code><code>      &quot;fields&quot;: [
</code><code>        {
</code><code>          &quot;keyRaw&quot;: &quot;name&quot;,
</code><code>          &quot;value&quot;: &quot;ex:MyModule/MyComponent#name&quot;
</code><code>        }
</code><code>      ]
</code><code>    }
</code><code>  ]
</code><code>}</code></pre>
<figcaption>
              <p><span class="label">Listing 3:</span> A description of a module <code>ex:MyModule</code> with a single component having constructor arguments using the JSON-LD serialization,
compacted with the <code>https:/​/​linkedsoftwaredependencies.org/bundles/npm/componentsjs/^4.0.0/components/context.jsonld</code> context.</p>
            </figcaption>
</figure>

          <p>Building upon the OO example from <a href="#module-oo">Listing 1</a>, we illustrate the usage of this vocabulary with an example in <a href="#module-om">Listing 3</a>, again using the JSON-LD serialization.
The only difference with the previous example, is the addition of the <code>constructorArguments</code> block,
which expands to <code>oo:constructorArguments</code> that is configured to always contain an RDF list.
The constructor arguments contain a single <code>om:ObjectMapping</code>, which is implied by the presence of <code>field</code>, which expands to <code>om:field</code>.
Since the field array contains just a single element (<code>om:ObjectMappingEntry</code>),
it represents an object with a single key and value.
The key is defined by <code>keyRaw</code> (expands to <code>om:fieldName</code>), which contains the constant <code>name</code>.
The value is defined by <code>value</code> (expands to <code>om:fieldValue</code>), which refers to the <code>ex:MyModule/MyComponent#name</code> parameter.</p>

          <p>The addition of an object mapping to a component requires no changes as to how a component is instantiated,
which means that our component from <a href="#module-om">Listing 3</a> can still be instantiated in the exact same way as the one from <a href="#module-oo">Listing 1</a>.
The only difference now, is that we are able to determine how exactly the parameter values are to be used for invoking the component constructor.
For example, the instantiation of <a href="#instance-oo">Listing 2</a> corresponds to the following code in JavaScript: <code>new MyComponent({ name: 'Some name' })</code></p>

          <p>A real-world example of the combined usage of the OO and OM vocabularies can be found at <a href="https://linkedsoftwaredependencies.org/bundles/npm/%40comunica%2Fcore/1.21.1/components/Actor.jsonld">https:/​/​linkedsoftwaredependencies.org/bundles/npm/%40comunica%2Fcore/1.21.1/components/Actor.jsonld</a>.</p>

          <h3 id="dereferenceability">Dereferenceability</h3>

          <p>In <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://linkedsoftwaredependencies.org/articles/describing-experiments/">previous work</a> <span class="references">[<a href="#ref-10">10</a>]</span>
we introduced the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://linkedsoftwaredependencies.org/">Linked Software Dependencies (LSD) service</a> <span class="references">[<a href="#ref-37">37</a>]</span>,
which makes all resource URLs within components files fully dereferenceable.</p>

          <p>Since our current focus is on enabling dependency injection for JavaScript,
this LSD service provides Linked Data subject pages for <em>all</em> packages within the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.npmjs.com/">npm package manager</a> <span class="references">[<a href="#ref-33">33</a>]</span> for JavaScript.
For example, the URL <a href="https://linkedsoftwaredependencies.org/bundles/npm/@comunica/core/1.21.1"><code>https:/​/​linkedsoftwaredependencies.org/bundles/npm/@comunica/core/1.21.1</code></a>
is an identifier for the <code>@comunica/core</code> package at version <code>1.21.1</code>.
<a href="#lsd-snippet">Listing 4</a> shows a snippet of the JSON-LD contents when dereferencing this URL.</p>

          <figure id="lsd-snippet" class="listing">
<pre><code>{
</code><code>  &quot;@context&quot;: [
</code><code>    &quot;https://linkedsoftwaredependencies.org/contexts/npm.jsonld&quot;,
</code><code>    { &quot;lsd&quot;: &quot;https://linkedsoftwaredependencies.org/&quot; }
</code><code>  ],
</code><code>  &quot;@type&quot;: &quot;doap:Version&quot;,
</code><code>  &quot;@id&quot;: &quot;lsd:bundles/npm/%40comunica%2Fcore/1.21.1&quot;,
</code><code>  &quot;name&quot;: &quot;@comunica/core&quot;,
</code><code>  &quot;version&quot;: &quot;1.21.1&quot;,
</code><code>  &quot;description&quot;: &quot;Lightweight, semantic and modular actor framework&quot;,
</code><code>  &quot;dependencies&quot;: {
</code><code>    &quot;@comunica/types&quot;: &quot;lsd:bundles/npm/%40comunica%2Ftypes/%5E1.21.1&quot;,
</code><code>    &quot;immutable&quot;: &quot;lsd:bundles/npm/immutable/%5E3.8.2&quot;
</code><code>  },
</code><code>  &quot;maintainers&quot;: [
</code><code>    {
</code><code>      &quot;email&quot;: &quot;mailto:rubensworks@gmail.com&quot;,
</code><code>      &quot;@id&quot;: &quot;lsd:users/npm/rubensworks&quot;
</code><code>    }
</code><code>  ],
</code><code>  &quot;dcterms:license&quot;: {
</code><code>      &quot;@id&quot;: &quot;https://spdx.org/licenses/MIT.html&quot;,
</code><code>      &quot;rdfs:label&quot;: &quot;MIT&quot;
</code><code>  },
</code><code>  &quot;lsd:scripts/npm/test&quot;: {
</code><code>      &quot;@id&quot;: &quot;lsd:bundles/npm/%40comunica%2Fcore/1.21.1/scripts/test&quot;
</code><code>  }
</code><code>}</code></pre>
<figcaption>
              <p><span class="label">Listing 4:</span> Part of the JSON-LD contents of <a href="https://linkedsoftwaredependencies.org/bundles/npm/@comunica/core/1.21.1"><code>https:/​/​linkedsoftwaredependencies.org/bundles/npm/@comunica/core/1.21.1</code></a>.</p>
            </figcaption>
</figure>

          <p>This LSD service allows creators of components files to automatically mint LSD-based URLs for their packages,
which will automatically become dereferenceable as soon as these packages are published to npm.
The LSD service thereby removes the dereferenceability responsibility from package developers that want to use dependency injection via Components.js,
but do not have the will or ability to make their component files dereferenceable themselves.
The LSD service is not required for the functioning of the Components.js framework,
so developers are not obligated to publish their package to npm or mint their own URLs if they do not have this desire.
But since publishing packages to npm in a common practise within the JavaScript community, we consider this a low barrier to entry.</p>

          <p>This dereferenceability is beneficial for enabling querying execution within and across component files.
For example, it enables using the follow-your-nose principle to analyze class inheritance chains of certain modules.
Another example in the domain of reproducibility is the ability to analyze which config parameters had the largest influence on the performance of a system,
assuming that the experimental results have also been linked to the semantic configuration.</p>

          <p>The long-term sustainability of the LSD service and its minted URLs is guaranteed by Ghent University,
<a href="https://www.ugent.be/en/research/datamanagement">which places a strong emphasis</a> on ensuring that data is preserved in the long term.
In the unlikely event that the LSD service would experience downtime,
all applications that make use of Components.js will still remain functional,
because the Components.js framework does not rely directly on the dereferenceability of these URLs.</p>

          <h3 id="generation-from-typescript">Generation from TypeScript</h3>

          <p>For larger projects, the manual creation of components files for all classes in the project can require significant manual effort, and can therefore become error-prone.
For projects that make use of a strongly-typed language, such as TypeScript,
all required information to create such components files is in fact already available implicitly via the source code files.
In order to minimize manual effort for such projects, we provide the open-source tool <a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/LinkedSoftwareDependencies/Components-Generator.js/"><em>Components-Generator.js</em></a> <span class="references">[<a href="#ref-38">38</a>]</span>
(<span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.5281/zenodo.5644902"><a href="https://doi.org/10.5281/zenodo.5644902">Zenodo</a></span> <span class="references">[<a href="#ref-39">39</a>]</span>) for TypeScript projects.</p>

          <p>Concretely, this tool can be installed into any TypeScript project.
When its command-line script is invoked, it scans all exported TypeScript classes within this project,
and generates corresponding components files for them.
In doing so, it preserves information that is important for dependency injection,
such as component extensions via class inheritance relationships and
parameter types with constructor arguments mapping via class constructors.</p>

          <p>For example, assuming an npm package named <code>my-package</code> containing the single TypeScript class from <a href="#generator-ts">Listing 5</a>,
Components-Generator.js will generate the components file in <a href="#generator-out">Listing 6</a>.</p>

          <figure id="generator-ts" class="listing">
<pre><code>/**
</code><code> * This is a great class!
</code><code> */
</code><code>export class MyClass extends OtherClass {
</code><code>  /**
</code><code>   * @param paramA - My parameter
</code><code>   */
</code><code>  constructor(paramA: boolean, paramB: number) {
</code><code>  
</code><code>  }
</code><code>}</code></pre>
<figcaption>
              <p><span class="label">Listing 5:</span> TypeScript class that is used as input to Components-Generator.js.</p>
            </figcaption>
</figure>

          <figure id="generator-out" class="listing">
<pre><code>{
</code><code>  &quot;@context&quot;: [
</code><code>    &quot;https://linkedsoftwaredependencies.org/bundles/npm/my-package/
</code><code>      ^1.0.0/components/context.jsonld&quot;
</code><code>  ],
</code><code>  &quot;@id&quot;: &quot;npmd:my-package&quot;,
</code><code>  &quot;components&quot;: [
</code><code>    {
</code><code>      &quot;@id&quot;: &quot;ex:MyFile#MyClass&quot;,
</code><code>      &quot;@type&quot;: &quot;Class&quot;,
</code><code>      &quot;requireElement&quot;: &quot;MyClass&quot;,
</code><code>      &quot;extends&quot;: &quot;ex:OtherFile#OtherClass&quot;,
</code><code>      &quot;comment&quot;: &quot;This is a great class!&quot;,
</code><code>      &quot;parameters&quot;: [
</code><code>        {
</code><code>          &quot;@id&quot;: &quot;ex:MyFile#MyClass_paramA&quot;,
</code><code>          &quot;range&quot;: &quot;xsd:boolean&quot;,
</code><code>          &quot;comment&quot;: &quot;My parameter&quot;,
</code><code>          &quot;unique&quot;: true,
</code><code>          &quot;required&quot;: true
</code><code>        },
</code><code>        {
</code><code>          &quot;@id&quot;: &quot;ex:MyFile#MyClass_paramB&quot;,
</code><code>          &quot;range&quot;: &quot;xsd:integer&quot;,
</code><code>          &quot;unique&quot;: true,
</code><code>          &quot;required&quot;: true
</code><code>        }
</code><code>      ],
</code><code>      &quot;constructorArguments&quot;: [
</code><code>        { &quot;@id&quot;: &quot;ex:MyFile#MyClass_paramA&quot; },
</code><code>        { &quot;@id&quot;: &quot;ex:MyFile#MyClass_paramB&quot; }
</code><code>      ]
</code><code>    }
</code><code>  ]
</code><code>}</code></pre>
<figcaption>
              <p><span class="label">Listing 6:</span> Components file that is generated by Components-Generator.js from the TypeScript file from <a href="#generator-ts">Listing 5</a>.</p>
            </figcaption>
</figure>

          <p>A real-world example of such conversion can be seen in the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/solid/community-server/">Community Solid Server</a> <span class="references">[<a href="#ref-8">8</a>]</span> project.
For example, the <code>CorsHandler</code> TypeScript class <br /> (<a href="https://github.com/solid/community-server/blob/9b6eab27bc4e5ee25d1d3c6ce5972e83db90c650/src/server/middleware/CorsHandler.ts#L31">https:/​/​github.com/solid/community-server/blob/9b6eab27bc4e5ee25d1d3c6ce5972e83db90c650/src/server/middleware/CorsHandler.ts#L31</a>) is converted to the components file at <a href="https://linkedsoftwaredependencies.org/bundles/npm/%40solid%2Fcommunity-server/2.0.0/dist/server/middleware/CorsHandler.jsonld">https:/​/​linkedsoftwaredependencies.org/bundles/npm/%40solid%2Fcommunity-server/2.0.0/dist/server/middleware/CorsHandler.jsonld</a>.</p>

        </div>
</section>

  <section id="system" inlist="" rel="schema:hasPart" resource="#system">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Dependency Injection Framework</h2>

          <p>Building on top of the declarative configurations that were explained in previous section,
we now discuss Components.js, which is a system that can interpret these configurations
for enabling dependency injection within JavaScript/TypeScript projects.
In this section, we first explain the main architecture, followed by the most relevant implementation details.</p>

          <h3 id="system-architecture">Architecture</h3>

          <p>The primary functional requirement of our architecture is the ability to perform dependency injection based on the configuration files from previous section.
Concretely, this involves <em>parsing</em> the configuration files, <em>interpreting</em> them, and <em>instantiating</em> the necessary components.
Next to these functional needs, we took the following non-functional requirements into account when designing the architecture:</p>

          <ul>
            <li>Usability: Developers using the framework should only be required to interact with a single entry point.</li>
            <li>Extensibility/Maintainability: The system should be robust against different future functional requirements.</li>
            <li>Performance: Parts of the architecture that are prone to performance issues should be cacheable.</li>
          </ul>

          <p>To meet these requirements, the Components.js dependency injection tool goes through three main phases:</p>

          <ul>
            <li>Loading: Initialization of DI components, discovery of modules, and loading of configuration files.</li>
            <li>Preprocessing: Handling of constructor arguments before construction.</li>
            <li>Construction: Instantiation of JavaScript classes based on configuration files.</li>
          </ul>

          <p>These three phases are handled by the <code>ComponentsManager</code>,
which acts as the main entrypoint of the framework
as can be seen in <a href="#architecture-main">Fig. 3</a> in the appendix.
This manager class is constructed via a static <code>build</code> method,
via which custom options can be passed,
such as a callback for loading modules and configuration files.
To meet the <em>usability</em> requirement, this is the only part that most users of the framework will interact with.</p>

          <p>For the sake of clarity, all UML architecture diagrams that we include in this article
only contain simplified representations of the actual classes.
So there may be minor differences when comparing the diagrams with the actual source code.</p>

          <p>Hereafter, we explain these three phases in more detail.</p>

          <h4 id="loading">Loading</h4>

          <p>When the <code>ComponentsManager</code> is being built,
the loading phase will be initiated,
which will make use of the classes within the load package.
The most important classes within this package are shown in <a href="#architecture-load">Fig. 4</a> in the appendix.
This phase aims to contain all major I/O operations, which could be expensive on slow disks and/or in large projects.
This allows later phases to purely work on memory.
Furthermore, the loaded information is designed to be cacheable,
which means that software that require repeated invocations may optimize the loading phase by caching certain parts,
which thereby meets the <em>performance</em> requirement.</p>

          <p>The <code>ModuleStateBuilder</code> is a class that is responsible for scanning the current JavaScript project and its dependencies.
The main objective of this class is to build an <code>IModuleState</code>, that contains information such as the paths to available components and dependencies.</p>

          <p><code>ComponentRegistry</code> and <code>ConfigRegistry</code> are classes that are exposed via a callback to invokers of <code>ComponentsManager.build()</code>.
These classes respectively enable modules and configurations to be registered,
after those modules and configurations will be loaded.</p>

          <h4 id="preprocessing">Preprocessing</h4>

          <p>Before a configuration is instantiated during the construction phase,
it always goes through a preprocessing phase.
Concretely, this involves processing all parameters and constructor arguments,
for which the most relevant classes and interfaces are shown in <a href="#architecture-preprocess">Fig. 5</a> in the appendix.
To meet the <em>extensibility</em> and <em>maintainability</em> requirements, the architecture allows different parameters and constructor arguments handlers to be injected.
This makes the architecture more robust against currently unforeseen functional requirements regarding the handling of parameters and constructor arguments.</p>

          <p><code>IConfigPreprocessor</code> is an interface that represents a preprocessing algorithm for a configuration,
and can have multiple implementations.</p>

          <p><code>ConfigPreprocessorComponent</code> is a preprocessor that is able to determine what component is being instantiated within a configuration.
It will check if the linked component exists, and it will validate all passed parameters.
For this parameter validation, the <code>ParameterHandler</code> class is used,
which works based on a list of <code>IParameterPropertyHandler</code>’s.
For instance, parameter property handlers exist for validating the range of parameters,
checking the uniqueness, handling default values, and more.</p>

          <p><code>ConfigPreprocessorComponentMapped</code> is another preprocessor that builds upon <code>ConfigPreprocessorComponent</code>,
so that it <em>additionally</em> handles constructor arguments as defined by the Object Mapping vocabulary.
Concretely, after validating parameters, it will handle the constructor arguments recursively
using a list of <code>IConstructorArgumentsElementMappingHandler</code>’s.
These handlers can handle specific types of constructor arguments and parameters,
such as the conversion of <code>om:ObjectMapping</code> to an object,
and the conversion of <code>om:ArrayMapping</code> to an array.</p>

          <p>The end-result of the preprocessing phase is a configuration that represents
the raw constructor call of a class, together with the required arguments.</p>

          <h4 id="construction">Construction</h4>

          <p>The construction phase is responsible for instantiating a configuration.
The main classes for this are shown in <a href="#architecture-construct">Fig. 6</a> in the appendix.
Like before, the <em>extensibility</em> and <em>maintainability</em> requirements also apply here regarding the way in which things are constructed,
for which we also provide the ability to inject different handlers.</p>

          <p><code>ConfigConstructorPool</code> is the main entrypoint that is used when a user instantiates a configuration via <code>ComponentsManager.instantiate()</code>.
Before actually instantiating a config,
it will first check if it had been instantiated before,
in which case it returns it from a cache.
This may occur for nested configurations that reuse the same component in different places.
If the config has not been instantiated before,
it will first go through the preprocessing phase as explained in the previous section,
and then the processed config will be passed on to the <code>ConfigConstructor</code>.</p>

          <p>The <code>ConfigConstructor</code> is able to convert the representation of a class constructor call into an actual constructor call to obtain an object.
For this, the arguments of the constructor are first converted into actual objects,
which is done via a list of <code>IArgumentConstructorHandler</code>’s.
For example, handlers exist to handle primitive values such as strings and numbers,
arrays, and references to other components (which requires a recursive call to <code>ConfigConstructorPool</code>).
Once the arguments have been resolved, the constructor can be applied to obtain the final instantiated object.</p>

          <p>By default, the <code>ConfigConstructor</code> assumes that configurations are instantiated via the <a href="https://nodejs.org/docs/latest/api/modules.html">CommonJS JavaScript standard</a>,
which is primarily used by the Node.js runtime environment.
However, Components.js has been designed to handle different kinds of instantiation,
which can be done via different <code>IConstructionStrategy</code>’s.
For instance, this allows the framework to be compatible with other upcoming JavaScript standards such as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">JavaScript modules</a>.</p>

          <h3 id="implementation">Implementation</h3>

          <p>Components.js has been implemented in TypeScript,
and is available on <a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/LinkedSoftwareDependencies/Components.js">GitHub</a> <span class="references">[<a href="#ref-5">5</a>]</span> and <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.5281/zenodo.1243988"><a href="https://doi.org/10.5281/zenodo.1243988">Zenodo</a></span> <span class="references">[<a href="#ref-40">40</a>]</span>
under the MIT license.
At the time of writing, the latest release is at version 4.4.1,
which is published via the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.npmjs.com/package/componentsjs">npm package manager</a> <span class="references">[<a href="#ref-6">6</a>]</span>.</p>

          <p>Due to the critical nature of this framework,
it is being tested thoroughly.
At the time of writing, it consists of 538 unit tests,
which reach a test coverage of 100%.</p>

          <p>Components.js is being maintained by IDLab via software projects that make use of this framework.
Furthermore, Components.js is part of the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.dev/association/">Comunica Association</a> <span class="references">[<a href="#ref-41">41</a>]</span>,
which is a non-profit organization that aims to ensure the long-term sustainability of certain open-source projects.
A sustainability of this project is available on <a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/LinkedSoftwareDependencies/Components.js/wiki/Sustainability-Plan">GitHub</a> <span class="references">[<a href="#ref-42">42</a>]</span>.</p>

          <p>Finally, in-depth <a property="schema:citation http://purl.org/spar/cito/cites" href="https://componentsjs.readthedocs.io/">documentation</a> <span class="references">[<a href="#ref-7">7</a>]</span> is available,
which explains how to create component and configuration files,
and how to invoke the DI tool.</p>

        </div>
</section>

  <section id="usage" inlist="" rel="schema:hasPart" resource="#usage">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Usage</h2>

          <p>A measure of the usage of an open-source project without the use of any tracking software is a picture that is always incomplete.
Nevertheless, we analyze the usage of Components.js in this section on two aspects:
empirical usage via available metrics, and in-use analysis of specific projects.
We discuss these two aspects hereafter.</p>

          <h3 id="usage-metrics">Usage Metrics</h3>

          <p>As the source code of Components.js is hosted on <a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/LinkedSoftwareDependencies/Components.js">GitHub</a> <span class="references">[<a href="#ref-5">5</a>]</span>,
it is possible to inspect the usage of this project within other projects hosted on GitHub.
As of August 2 2021, there are 9 GitHub projects that depend on Components.js directly, and 268 that depend on it indirectly via transitive dependencies.
This shows that Components.js is primarily used as a core library to support larger projects that have a broad usage.</p>

          <p>The <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.npmjs.com/package/componentsjs">npm package manager</a> <span class="references">[<a href="#ref-6">6</a>]</span> from which Components.js can be installed offers us additional insights.
For the week of July 26 2021 until August 1 2021 (the last completed week before writing this section) there were 5.351 downloads, which is an average number when comparing it to previous weeks.
However, there are outliers for which Components.js has weekly downloads peak up to around 200.000 downloads.</p>

          <p>While these GitHub and npm metrics give us <em>some</em> insight into the usage of Components.js,
they are incomplete, as projects may be hosted on other source code platforms such as GitLab, Bitbucket, or even private instances.
Furthermore, direct downloads from npm are also incomplete, as downstream users may use bundling tools such as <a property="schema:citation http://purl.org/spar/cito/cites" href="https://webpack.js.org/">Webpack</a> <span class="references">[<a href="#ref-43">43</a>]</span>
to incorporate the Components.js source code directly within their library, which makes downloads of that library not go via the the Components.js npm package anymore.
On the other hand, automated downloads by bots (e.g. for mirror services) may artificially increase the download number, without actually representing real usage.
Therefore, we conclude that the metrics reported here are merely an estimate.</p>

          <h3 id="in-use-analysis">In-use Analysis</h3>

          <p>In the previous section, we provided an informed estimate as to <em>how much</em> Components.js is being used.
In this section, we provide an analysis of <em>in what way</em> Components.js is being used in four real-world projects:
Community Solid Server, Handlers.js, Digita Identity Proxy, and Comunica.</p>

          <h4 id="community-solid-server">Community Solid Server</h4>

          <p>The <a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/solid/community-server/">Community Solid Server</a> <span class="references">[<a href="#ref-8">8</a>]</span>
is a server-side implementation of the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://solid.github.io/specification/">Solid specifications</a> <span class="references">[<a href="#ref-44">44</a>]</span>,
which provides a basis for the Solid decentralization effort.
When such a server is hosted, it allows users to create their own personal storage space (pod) and identity,
so that this data can be used within any external Solid application.
This server is written in TypeScript, and is being developed by <a property="schema:citation http://purl.org/spar/cito/cites" href="https://inrupt.com/">Inrupt</a> <span class="references">[<a href="#ref-45">45</a>]</span> and <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.imec-int.com/en">imec</a> <span class="references">[<a href="#ref-46">46</a>]</span>,
which includes authors of this article.</p>

          <p>This server makes use of dependency injection because a primary goal of the server is to be as flexible as possible,
so that developers can easily modify the capabilities of the server, or even add additional capabilities.
This is especially useful in the context of research, where new components can be added to the server for experimentation,
before they are standardized and become a part of the Solid specifications.
To enable this level of flexibility, all components within this server are loosely coupled,
and are wired via customizable Components.js configuration files.</p>

          <p>Since the Community Solid Server makes use of TypeScript, it is able to make use of the Components-Generator.js tool as explained before in <a href="#configs">Section 3</a>,
which avoids the need to manually create components files, and thereby significantly simplifies the usage of Components.js within this project.
At the time of writing, this server contains 246 components that can be customized via specific parameters, and wired together to form a server instance with specific capabilities.</p>

          <h4 id="handlersjs">Handlers.js</h4>

          <p><a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/digita-ai/handlersjs">Handlers.js</a> <span class="references">[<a href="#ref-47">47</a>]</span> aims to provide a comprehensive collection of generic logic classes,
that can be wired together via the composition pattern.
While this project is still under development, it already provides numerous handlers and services pertaining to
data flows, storage, logging, error handling, as well as logic about serving data over HTTP (routing, CORS, content negotiation …).
This project is written in TypeScript, and is being developed by <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.digita.ai/">Digita</a> <span class="references">[<a href="#ref-48">48</a>]</span>.</p>

          <p>In contrast to the Community Solid Server, Handlers.js is not meant to be usable by itself as standalone tool.
Instead, it is an accompanying library that can be used by other tools.
The components within Handlers.js are meant to capture common patterns within projects that depend on composition-based components,
so that they can be reused by other projects that make use of DI frameworks such as Components.js.
While Components.js is the primary DI framework this library was designed for,
it does not strictly depend on it thanks to the loosely coupling of the Components.js DI layer and software implementations.</p>

          <p>Handlers.js also make use of the Components-Generator.js tool to convert TypeScript classes into components files.
At the time of writing, this project exposes 40 components that range from abstract logic flows to specific ones for setting up a simple HTTP server.
Since components within Components.js have global semantics, these components can be easily reused across projects.</p>

          <h4 id="digita-identity-proxy">Digita Identity Proxy</h4>

          <p>The Digita Identity Proxy (not public at the time of writing) is a <a property="schema:citation http://purl.org/spar/cito/cites" href="https://solid.github.io/authentication-panel/solid-oidc/">Solid-OIDC</a> <span class="references">[<a href="#ref-49">49</a>]</span>-compliant proxy server
that acts as a modular, and easily configurable compatibility layer for classic <a property="schema:citation http://purl.org/spar/cito/cites" href="https://openid.net/connect/">OIDC</a> <span class="references">[<a href="#ref-50">50</a>]</span> Identity Providers.
It enables Solid apps to authenticate at Solid pod servers with these existing identity services, without any necessary modification.
This project is also written in TypeScript, and is under development by <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.digita.ai/">Digita</a> <span class="references">[<a href="#ref-48">48</a>]</span>.</p>

          <p>Several components exists that enable additional functionality of Solid-OIDC,
which can be plugged into the proxy when the need exists.
With Components.js, these components can be easily configured and plugged in via a configuration file.</p>

          <h4 id="usage-comunica">Comunica</h4>

          <p><a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.github.io/Article-ISWC2018-Resource/">Comunica</a> <span class="references">[<a href="#ref-9">9</a>]</span> is another project that makes use of Components.js at its core.
Comunica is a highly modular SPARQL query engine
that has been designed to be a flexible research platform for SPARQL query execution.
It has been written in TypeScript, and is developed by Ghent University, by authors of this article.</p>

          <p>The modular nature of Comunica calls for a dependency injection framework due to its <a href="https://comunica.dev/docs/modify/advanced/architecture_core/">actor-mediator-bus paradigm</a>.
All logic within Comunica is placed within small actors,
which are registered on task-specific buses following the publish-subscribe pattern.
In order to select a certain actor on a bus for achieving a certain task,
the mediator pattern is applied, which allows different actors to be selected based on different actions.
These actors, buses, and mediators are loosely coupled with each other,
and are wired together via Components.js configuration files.
For example, this allows users of Comunica to create and plug in a different algorithm for resolving a certain SPARQL query operator.</p>

          <p>At the time of writing, Comunica does not yet make use of the Components-Generator.js tool,
as it was developed before Components-Generator.js was created.
Therefore, all components files within Comunica are created manually,
which shows that Components.js is flexible in this regard.</p>

          <p>As Comunica is a research platform for research around query execution,
the ability to <em>reproduce</em> experiments is crucial.
This is where the benefit of Components.js becomes especially apparent.
It is often the case that research articles with experimental results only report on the used software,
without mentioning the exact version and configuration that was used.
When using a Components.js configuration file,
the necessary semantics for accurately replicating such experiments are available as Linked Data.
The reproducibility of <a property="schema:citation http://purl.org/spar/cito/cites" href="https://git.its.aau.dk/CLAAUDIA/teach_reproducibility/raw/commit/dbea465c0d10bca50b0cca23fd93afd0ffea08dc/litt/Wavelab%20and%20reproducible%20research.pdf">experimental results is often considered to be even more important than the research article itself</a> <span class="references">[<a href="#ref-51">51</a>]</span>,
as the article can be considered to be merely <em>advertising of the scholarship</em>.
For example, the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.github.io/Article-ISWC2018-Resource/">Comunica research article</a> <span class="references">[<a href="#ref-9">9</a>]</span> contains an <a href="https://comunica.github.io/Article-ISWC2018-Resource/#evaluation-workflow" class="mandatory" data-link-text="https:/​/​comunica.github.io/​Article-​ISWC2018-​Resource/​#evaluation-​workflow">experiment workflow</a>
that is backed by the used Components.js configuration files.</p>

        </div>
</section>

  <section id="conclusions" inlist="" rel="schema:hasPart" resource="#conclusions">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Conclusions</h2>

          <p>After more than four years of development, Components.js has become a stable Dependency Injection framework for TypeScript and JavaScript projects,
and has seen a significant uptake by popular tools that make use of it as core technology.
It enables the primary tasks of a DI framework,
but thanks to its semantic configuration files,
it also brings with it the power of Linked Data and the Semantic Web for enabling globally interoperable and discoverable configurations.
Using the Linked Software Dependencies service, components and configurations become dereferenceable and citable,
which allows software configurations to be shared easily with others,
which is for example beneficial for improving the reproducibility of software experiments.</p>

          <p>The previous section has shown that Components.js provides significant value in real-world applications.
On the one hand, tools such as the Community Solid Server and Comunica allow developers and researchers to rewire these applications based on their specific needs.
On the other hand, applications by companies such as Digita depend on this flexibility for making logic changes via configuration files,
as they want to enable their clients to make changes by only modifying the configuration files,
since their clients are sometimes non-technical people that have limited programming knowledge.</p>

          <p>We can recommend Components.js for TypeScript/JavaScript projects that have at least a subset of the following characteristics:</p>

          <ul>
            <li>Architectures that require <strong>high modularity and flexibility</strong>;</li>
            <li>Need to modify wiring of components <strong>without changing code</strong>;</li>
            <li>Need for ability to <strong>share wiring configurations</strong> with others;</li>
            <li>Managing and including <strong>configurations across different projects</strong>;</li>
            <li>Using <strong>configurations in other contexts</strong>.</li>
          </ul>

          <p>As with all DI frameworks, Components.js comes with the downside that for large applications,
configurations can become complex and logic flow may be harder to follow.
In order to mitigate these risks, we recommend a structured management of configuration files,
which may involve splitting up configuration files based on an architecture’s primary subsystems,
which is the approach followed by large projects such as Community Solid Server and Comunica.</p>

          <p>The dereferenceability of software configurations by IRI is also an important benefit of the Components.js framework.
In the introduction, we mentioned that this dereferenceability could be beneficial for
experimental research, static program analysis, and semantic workflows.
So far, we only have concrete proof of the experimental research use case as shown in <a href="#usage-comunica">Subsubsection 5.2.4</a>.
We hope to see examples of the other use cases making use of this functionality in future work.</p>

          <p>In future work, we do not foresee the need for any major changes or additions within the Components.js framework itself,
aside from keeping up with new language features from JavaScript and TypeScript.
However, all large projects that make use of Components.js have identified the need for better tooling to create and manage configuration files.
For example, the Comunica project is developing a <a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/comunica/comunica-packager">graphical user interface</a> <span class="references">[<a href="#ref-52">52</a>]</span>
to visually customize the wiring of the engine, which can then be exported into a reusable configuration file.
Since Components.js configurations make use of the Linked Data principles,
it is possible to create a generic user interface to create such configuration files for any project that makes use of Components.js.
Furthermore, since components and configuration files are largely programming language-independent,
it is possible to create equivalent implementations of Components.js for other OO languages such as Java and C#.
Another venue that deserves investigation is the task of automatically letting the Linked Software Dependencies service
execute the Components-Generator.js on all TypeScript projects that do not provide component files yet,
which could open up a huge domain on injectable components.</p>

          <p>In general, Components.js gives us the necessary foundation for building next-level applications that depend on high flexibility, such as smart agents.
These applications are crucial for environments such as Linked Data and the Semantic Web,
which require and benefit from this level of flexibility.
Therefore, DI frameworks such as Components.js pave the road towards a world with more flexible applications.</p>

        </div>
</section>

</main>

<footer>
  <section id="acknowledgements" inlist="" rel="schema:hasPart" resource="#acknowledgements">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Acknowledgements</h2>

          <p>We thank Wouter Termont for sharing his insights into the usage of Components.js within the products of Digita.
The described research activities were funded by Ghent University and imec.
Ruben Taelman is a postdoctoral fellow of the Research Foundation – Flanders (FWO) (1274521N).</p>

        </div>
</section>

  <div class="printonly" style="height: 30px">&nbsp;</div>
<section>
<h2 id="references">References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="#designpatterns" typeof="schema:Article">Gamma, E., Helm, R., Johnson, R., Vlissides, J.: Elements of Reusable Object-Oriented Software. Design Patterns. massachusetts: Addison-Wesley Publishing Company. (1995).</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="https://martinfowler.com/articles/injection.html" typeof="schema:CreativeWork">Fowler, M.: Inversion of Control Containers and the Dependency Injection pattern. <a href="https://martinfowler.com/articles/injection.html">https:/​/​martinfowler.com/articles/injection.html</a> (2004).</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="https://www.w3.org/DesignIssues/LinkedData.html" typeof="schema:CreativeWork">Berners-Lee, T.: Linked Data. <a href="https://www.w3.org/DesignIssues/LinkedData.html">https:/​/​www.w3.org/DesignIssues/LinkedData.html</a> (2006).</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="https://www-sop.inria.fr/acacia/cours/essi2006/Scientific%20American_%20Feature%20Article_%20The%20Semantic%20Web_%20May%202001.pdf" typeof="schema:Article">Berners-Lee, T., Hendler, J., Lassila, O., others: The Semantic Web. Scientific American. 284, 28–37 (2001).</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="https://github.com/LinkedSoftwareDependencies/Components.js" typeof="schema:CreativeWork">Taelman, R., Van Herwegen, J., Verborgh, R.: Components.js Source Code. <a href="https://github.com/LinkedSoftwareDependencies/Components.js">https:/​/​github.com/LinkedSoftwareDependencies/Components.js</a> (2021).</dd>
  <dt id="ref-6">[6]</dt>
  <dd resource="https://www.npmjs.com/package/componentsjs" typeof="schema:CreativeWork">Taelman, R., Van Herwegen, J., Verborgh, R.: Components.js Package. <a href="https://www.npmjs.com/package/componentsjs">https:/​/​www.npmjs.com/package/componentsjs</a> (2021).</dd>
  <dt id="ref-7">[7]</dt>
  <dd resource="https://componentsjs.readthedocs.io/" typeof="schema:CreativeWork">Taelman, R.: Components.js Documentation. <a href="https://componentsjs.readthedocs.io/">https:/​/​componentsjs.readthedocs.io/</a> (2021).</dd>
  <dt id="ref-8">[8]</dt>
  <dd resource="https://github.com/solid/community-server/" typeof="schema:CreativeWork">Van Herwegen, J., Verborgh, R., Taelman, R.: Community Solid Server Source Code. <a href="https://github.com/solid/community-server/">https:/​/​github.com/solid/community-server/</a> (2021).</dd>
  <dt id="ref-9">[9]</dt>
  <dd resource="https://comunica.github.io/Article-ISWC2018-Resource/" typeof="schema:Article">Taelman, R., Van Herwegen, J., Vander Sande, M., Verborgh, R.: Comunica: a Modular SPARQL Query Engine for the Web. In: Proceedings of the 17th International Semantic Web Conference (2018).</dd>
  <dt id="ref-10">[10]</dt>
  <dd resource="https://linkedsoftwaredependencies.org/articles/describing-experiments/" typeof="schema:Article">Van Herwegen, J., Taelman, R., Capadisli, S., Verborgh, R.: Describing configurations of software experiments as Linked Data. In: Proceedings of the 1st SemSci Workshop (2017).</dd>
  <dt id="ref-11">[11]</dt>
  <dd resource="https://linkedsoftwaredependencies.org/vocabularies/object-mapping" typeof="schema:CreativeWork">Taelman, R.: Object Mapping vocabulary. <a href="https://linkedsoftwaredependencies.org/vocabularies/object-mapping">https:/​/​linkedsoftwaredependencies.org/vocabularies/object-mapping</a> (2017).</dd>
  <dt id="ref-12">[12]</dt>
  <dd resource="https://nixos.org/" typeof="schema:CreativeWork">NixOS - NixOS Linux. <a href="https://nixos.org/">https:/​/​nixos.org/</a> (2021).</dd>
  <dt id="ref-13">[13]</dt>
  <dd resource="#malone2014software" typeof="schema:Article">Malone, J., Brown, A., Lister, A.L., Ison, J., Hull, D., Parkinson, H., Stevens, R.: The Software Ontology (SWO): a resource for reproducibility in biomedical data analysis, curation and digital preservation. Journal of biomedical semantics. 5, 25 (2014).</dd>
  <dt id="ref-14">[14]</dt>
  <dd resource="http://usefulinc.com/ns/doap" typeof="schema:CreativeWork">Wilder-James, E.: Description of a Project. <a href="http://usefulinc.com/ns/doap">http:/​/​usefulinc.com/ns/doap</a> (2017).</dd>
  <dt id="ref-15">[15]</dt>
  <dd resource="https://dx.doi.org/10.1145/2814864.2814882" typeof="schema:Article">Rautenberg, S., Ermilov, I., Marx, E., Auer, S., Ngonga Ngomo, A.-C.: LODFlow: A Workflow Management System for Linked Data Processing. In: Proceedings of the 11th International Conference on Semantic Systems. pp. 137–144. ACM (2015).</dd>
  <dt id="ref-16">[16]</dt>
  <dd resource="https://dx.doi.org/10.1016/j.websem.2015.01.003" typeof="schema:Article">Belhajjame, K., Zhao, J., Garijo, D., Gamble, M., Hettne, K., Palma, R., Mina, E., Corcho, O., Gómez-Pérez, J.M., Bechhofer, S., Klyne, G., Goble, C.: Using a suite of ontologies for preserving workflow-centric research objects. Web Semantics: Science,  Services and Agents on the World Wide Web. 32, 16–42 (2015).</dd>
  <dt id="ref-17">[17]</dt>
  <dd resource="https://dx.doi.org/10.1109/escience.2014.47" typeof="schema:Article">Mayer, R., Miksa, T., Rauber, A.: Ontologies for Describing the Context of Scientific Experiment Processes. In: 10th International Conference on e-Science. IEEE (2014).</dd>
  <dt id="ref-18">[18]</dt>
  <dd resource="https://www.w3.org/TR/prov-o/" typeof="schema:CreativeWork">Lebo, T., Sahoo, S., McGuinness, D.: Prov-O: The PROV Ontology. W3C, <a href="https://www.w3.org/TR/prov-o/">https:/​/​www.w3.org/TR/prov-o/</a> (2013).</dd>
  <dt id="ref-19">[19]</dt>
  <dd resource="https://dx.doi.org/10.1145/2110497.2110504" typeof="schema:Article">Garijo, D., Gil, Y.: A new approach for publishing workflows: abstractions, standards, and linked data. In: Proceedings of the 6th workshop on Workflows in support of large-scale science. pp. 47–56. ACM (2011).</dd>
  <dt id="ref-20">[20]</dt>
  <dd resource="http://rdf-vocabulary.ddialliance.org/discovery.html" typeof="schema:CreativeWork">Bosch, T., Cyganiak, R., Wackerow, J., Zapilko, B.: DDI-RDF Discovery Vocabulary. <a href="http://rdf-vocabulary.ddialliance.org/discovery.html">http:/​/​rdf-vocabulary.ddialliance.org/discovery.html</a> (2015).</dd>
  <dt id="ref-21">[21]</dt>
  <dd resource="#oberle2009ontology" typeof="schema:Chapter">Oberle, D., Grimm, S., Staab, S.: An ontology for software. In: Handbook on ontologies. pp. 383–402. Springer (2009).</dd>
  <dt id="ref-22">[22]</dt>
  <dd resource="#ruy2016seon" typeof="schema:Article">Ruy, F.B., de Almeida Falbo, R., Barcellos, M.P., Costa, S.D., Guizzardi, G.: SEON: A software engineering ontology network. In: European Knowledge Acquisition Workshop. pp. 527–542. Springer (2016).</dd>
  <dt id="ref-23">[23]</dt>
  <dd resource="#GraphGen4Code" typeof="schema:CreativeWork">Abdelaziz, I., Dolby, J., McCusker, J., Srinivas, K.: A Toolkit for Generating Code Knowledge Graphs (2021).</dd>
  <dt id="ref-24">[24]</dt>
  <dd resource="https://spring.io/" typeof="schema:CreativeWork">Spring. <a href="https://spring.io/">https:/​/​spring.io/</a> (2021).</dd>
  <dt id="ref-25">[25]</dt>
  <dd resource="https://github.com/google/guice" typeof="schema:CreativeWork">Guice. <a href="https://github.com/google/guice">https:/​/​github.com/google/guice</a> (2021).</dd>
  <dt id="ref-26">[26]</dt>
  <dd resource="https://github.com/google/dagger" typeof="schema:CreativeWork">Dagger. <a href="https://github.com/google/dagger">https:/​/​github.com/google/dagger</a> (2021).</dd>
  <dt id="ref-27">[27]</dt>
  <dd resource="https://github.com/young-steveo/bottlejs" typeof="schema:CreativeWork">BottleJS. <a href="https://github.com/young-steveo/bottlejs">https:/​/​github.com/young-steveo/bottlejs</a> (2021).</dd>
  <dt id="ref-28">[28]</dt>
  <dd resource="https://github.com/cujojs/wire" typeof="schema:CreativeWork">Wire. <a href="https://github.com/cujojs/wire">https:/​/​github.com/cujojs/wire</a> (2021).</dd>
  <dt id="ref-29">[29]</dt>
  <dd resource="https://github.com/jaredhanson/electrolyte" typeof="schema:CreativeWork">Electrolyte. <a href="https://github.com/jaredhanson/electrolyte">https:/​/​github.com/jaredhanson/electrolyte</a> (2021).</dd>
  <dt id="ref-30">[30]</dt>
  <dd resource="https://github.com/inversify/InversifyJS" typeof="schema:CreativeWork">InversifyJS. <a href="https://github.com/inversify/InversifyJS">https:/​/​github.com/inversify/InversifyJS</a> (2021).</dd>
  <dt id="ref-31">[31]</dt>
  <dd resource="https://nodejs.org/en/" typeof="schema:CreativeWork">Node.js. <a href="https://nodejs.org/en/">https:/​/​nodejs.org/en/</a> (2021).</dd>
  <dt id="ref-32">[32]</dt>
  <dd resource="https://v8.dev/" typeof="schema:CreativeWork">V8 JavaScript engine. <a href="https://v8.dev/">https:/​/​v8.dev/</a> (2021).</dd>
  <dt id="ref-33">[33]</dt>
  <dd resource="https://www.npmjs.com/" typeof="schema:CreativeWork">npm. <a href="https://www.npmjs.com/">https:/​/​www.npmjs.com/</a> (2021).</dd>
  <dt id="ref-34">[34]</dt>
  <dd resource="https://deno.land/" typeof="schema:CreativeWork">Deno. <a href="https://deno.land/">https:/​/​deno.land/</a> (2021).</dd>
  <dt id="ref-35">[35]</dt>
  <dd resource="https://www.w3.org/TR/json-ld/" typeof="schema:CreativeWork">JSON-LD 1.1: a JSON-based serialization for linked data. <a href="https://www.w3.org/TR/json-ld/">https:/​/​www.w3.org/TR/json-ld/</a></dd>
  <dt id="ref-36">[36]</dt>
  <dd resource="https://github.com/ewilderj/doap/wiki" typeof="schema:CreativeWork">Wilder-James, E.: Description of a Project. <a href="https://github.com/ewilderj/doap/wiki">https:/​/​github.com/ewilderj/doap/wiki</a> (2017).</dd>
  <dt id="ref-37">[37]</dt>
  <dd resource="https://linkedsoftwaredependencies.org/" typeof="schema:CreativeWork">Van Herwegen, J., Taelman, R.: Linked Software Dependencies. <a href="https://linkedsoftwaredependencies.org/">https:/​/​linkedsoftwaredependencies.org/</a> (2021).</dd>
  <dt id="ref-38">[38]</dt>
  <dd resource="https://github.com/LinkedSoftwareDependencies/Components-Generator.js/" typeof="schema:CreativeWork">Taelman, R.: Components.js Generator Source Code. <a href="https://github.com/LinkedSoftwareDependencies/Components-Generator.js/">https:/​/​github.com/LinkedSoftwareDependencies/Components-Generator.js/</a> (2021).</dd>
  <dt id="ref-39">[39]</dt>
  <dd resource="https://dx.doi.org/10.5281/zenodo.5644902" typeof="schema:CreativeWork">Taelman, R., Herwegen, J.V., Heyvaert, P.: LinkedSoftwareDependencies/Components-  Generator.js: 2.6.1. <a href="https://doi.org/10.5281/zenodo.5644902">https:/​/​doi.org/10.5281/zenodo.5644902</a> (2021).</dd>
  <dt id="ref-40">[40]</dt>
  <dd resource="https://dx.doi.org/10.5281/zenodo.1243988" typeof="schema:CreativeWork">Taelman, R., Verborgh, R., Herwegen, J.V., Noterman, L.: LinkedSoftwareDependencies/Components.js 2.0.0. <a href="https://doi.org/10.5281/zenodo.1243988">https:/​/​doi.org/10.5281/zenodo.1243988</a> (2018).</dd>
  <dt id="ref-41">[41]</dt>
  <dd resource="https://comunica.dev/association/" typeof="schema:CreativeWork">Comunica Association. <a href="https://comunica.dev/association/">https:/​/​comunica.dev/association/</a> (2021).</dd>
  <dt id="ref-42">[42]</dt>
  <dd resource="https://github.com/LinkedSoftwareDependencies/Components.js/wiki/Sustainability-Plan" typeof="schema:CreativeWork">Taelman, R.: Components.js Sustainability Plan. <a href="https://github.com/LinkedSoftwareDependencies/Components.js/wiki/Sustainability-Plan">https:/​/​github.com/LinkedSoftwareDependencies/Components.js/wiki/Sustainability-Plan</a> (2017).</dd>
  <dt id="ref-43">[43]</dt>
  <dd resource="https://webpack.js.org/" typeof="schema:CreativeWork">webpack. <a href="https://webpack.js.org/">https:/​/​webpack.js.org/</a> (2021).</dd>
  <dt id="ref-44">[44]</dt>
  <dd resource="https://solid.github.io/specification/" typeof="schema:CreativeWork">Solid Technical Reports. <a href="https://solid.github.io/specification/">https:/​/​solid.github.io/specification/</a> (2021).</dd>
  <dt id="ref-45">[45]</dt>
  <dd resource="https://inrupt.com/" typeof="schema:CreativeWork">Inrupt. <a href="https://inrupt.com/">https:/​/​inrupt.com/</a> (2021).</dd>
  <dt id="ref-46">[46]</dt>
  <dd resource="https://www.imec-int.com/en" typeof="schema:CreativeWork">imec R&amp;D. <a href="https://www.imec-int.com/en">https:/​/​www.imec-int.com/en</a> (2021).</dd>
  <dt id="ref-47">[47]</dt>
  <dd resource="https://github.com/digita-ai/handlersjs" typeof="schema:CreativeWork">Termont, W.: Handlers.js. <a href="https://github.com/digita-ai/handlersjs">https:/​/​github.com/digita-ai/handlersjs</a> (2021).</dd>
  <dt id="ref-48">[48]</dt>
  <dd resource="https://www.digita.ai/" typeof="schema:CreativeWork">Digita - Solid for Enterprises. <a href="https://www.digita.ai/">https:/​/​www.digita.ai/</a> (2021).</dd>
  <dt id="ref-49">[49]</dt>
  <dd resource="https://solid.github.io/authentication-panel/solid-oidc/" typeof="schema:CreativeWork">Coburn, A., Pavlik, elf, Zagidulin, D.: Solid-OIDC. <a href="https://solid.github.io/authentication-panel/solid-oidc/">https:/​/​solid.github.io/authentication-panel/solid-oidc/</a> (2021).</dd>
  <dt id="ref-50">[50]</dt>
  <dd resource="https://openid.net/connect/" typeof="schema:CreativeWork">OpenID Connect. <a href="https://openid.net/connect/">https:/​/​openid.net/connect/</a> (2020).</dd>
  <dt id="ref-51">[51]</dt>
  <dd resource="https://git.its.aau.dk/CLAAUDIA/teach_reproducibility/raw/commit/dbea465c0d10bca50b0cca23fd93afd0ffea08dc/litt/Wavelab%20and%20reproducible%20research.pdf" typeof="schema:CreativeWork">Buckheit, J.B., Donoho, D.L.: WaveLab and Reproducible Research. Stanford University, <a href="https://git.its.aau.dk/CLAAUDIA/teach_reproducibility/raw/commit/dbea465c0d10bca50b0cca23fd93afd0ffea08dc/litt/Wavelab%20and%20reproducible%20research.pdf">https:/​/​git.its.aau.dk/CLAAUDIA/teach_reproducibility/raw/commit/dbea465c0d10bca50b0cca23fd93afd0ffea08dc/litt/Wavelab%20and%20reproducible%20research.pdf</a> (1995).</dd>
  <dt id="ref-52">[52]</dt>
  <dd resource="https://github.com/comunica/comunica-packager" typeof="schema:CreativeWork">Comunica Packager Source Code. <a href="https://github.com/comunica/comunica-packager">https:/​/​github.com/comunica/comunica-packager</a> (2020).</dd>
</dl>
</section>
</footer>

</div>

<div id="appendix">
    <h1 id="appendix">Appendix</h1>
    <section id="uml-diagrams" inlist="" rel="schema:hasPart" resource="#uml-diagrams">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Architectural Diagrams</h2>

        <p>This appendix section contains the architectural diagrams that were discussed in <a href="#system-architecture">Subsection 4.1</a>.
<a href="#architecture-main">Fig. 3</a> contains the main entrypoint of the framework,
<a href="#architecture-load">Fig. 4</a> represents the loading phase,
<a href="#architecture-preprocess">Fig. 5</a> represents the preprocessing phase,
and <a href="#architecture-construct">Fig. 6</a> represents the construction phase.</p>

        <figure id="architecture-main">
<img src="img/architecture-main.svg" alt="[Components.js Architecture - Main package]" />
<figcaption>
            <p><span class="label">Fig. 3:</span> UML diagram of the classes within the main package,
which contains the main entrypoint of the framework.</p>
          </figcaption>
</figure>

        <figure id="architecture-load">
<img src="img/architecture-load.svg" alt="[Components.js Architecture - Load package]" />
<figcaption>
            <p><span class="label">Fig. 4:</span> UML diagram of the classes within the load package,
which are responsible for loading components and configurations.</p>
          </figcaption>
</figure>

        <figure id="architecture-preprocess">
<img src="img/architecture-preprocess.svg" alt="[Components.js Architecture - Preprocess package]" />
<figcaption>
            <p><span class="label">Fig. 5:</span> UML diagram of the classes within the preprocess package,
which are responsible for preprocessing config parameters and constructor arguments.</p>
          </figcaption>
</figure>

        <figure id="architecture-construct">
<img src="img/architecture-construct.svg" alt="[Components.js Architecture - Construct package]" />
<figcaption>
            <p><span class="label">Fig. 6:</span> UML diagram of the classes within the construct package,
which are responsible for instantiating configs according to a certain strategy.</p>
          </figcaption>
</figure>

      </div>
</section>

  </div>

</div>



</body>
</html>
