<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title property="foaf:name schema:name">Components.js: Semantic Dependency Injection</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="citation_title" content="Components.js: Semantic Dependency Injection">
  <meta name="citation_author" content="Ruben Taelman" />
  <meta name="citation_author" content="Joachim Van Herwegen" />
  <meta name="citation_author" content="Miel Vander Sande" />
  <meta name="citation_author" content="Ruben Verborgh" />
  
  <meta name="citation_publication_date" content="2021/07/26" />
</head>

<body prefix="dctypes: http://purl.org/dc/dcmitype/ pimspace: http://www.w3.org/ns/pim/space# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# lsc: http://linkedscience.org/lsc/ns#" typeof="schema:CreativeWork sioc:Post prov:Entity lsc:Research">
  <header>
  <h1 id="componentsjs-semantic-dependency-injection">Components.js: Semantic Dependency Injection</h1>

  <ul id="authors">
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="http://www.rubensworks.net/" typeof="foaf:Person schema:Person" resource="http://www.rubensworks.net/#me">Ruben Taelman</a><a href="#idlab"><sup>1</sup></a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="#" typeof="foaf:Person schema:Person" resource="https://data.verborgh.org/people/joachim_van_herwegen">Joachim Van Herwegen</a><a href="#idlab"><sup>1</sup></a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="#" typeof="foaf:Person schema:Person" resource="https://data.verborgh.org/people/miel_vander_sande">Miel Vander Sande</a><a href="#meemoo"><sup>2</sup></a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://ruben.verborgh.org/" typeof="foaf:Person schema:Person" resource="https://ruben.verborgh.org/profile/#me">Ruben Verborgh</a><a href="#idlab"><sup>1</sup></a></li>
  </ul>

  <ul id="affiliations">
    <li id="idlab"><sup>1</sup>IDLab,
          Department of Electronics and Information Systems,
          Ghent University – imec
          <br />E-mail: ruben.taelman@ugent.be</li>
    <li id="meemoo"><sup>2</sup>meemoo, Flemish Institute for Archives</li>
  </ul>

</header>

<div id="content">
  <section id="abstract" inlist="" rel="schema:hasPart" resource="#abstract">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Abstract</h2>
      <!-- Context      -->
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.
<!-- Need         -->
Vestibulum finibus dignissim augue, id pellentesque est facilisis non.
<!-- Task         -->
Donec fringilla dolor non neque iaculis blandit.
<!-- Object       -->
Praesent aliquet eleifend iaculis.
<!-- Findings     -->
Quisque pellentesque at odio ac bibendum.
<!-- Conclusion   -->
Pellentesque imperdiet felis urna, quis facilisis lacus gravida non.
<!-- Perspectives -->
Donec quis lectus eget sem tempor tristique pellentesque in dolor.</p>

    </div>
</section>


<div class="double-column">

<main>
  <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Introduction</h2>

          <p>Object-oriented (OO) programming is a highly popular paradigm within the domain of software engineering.
Considering <em>objects</em> containing data and logic as primary software elements
makes it easy for developers to understand software,
as it makes software resemble real-world mechanisms with interacting physical objects.
Most OO languages allow objects to be instantiated from <em>classes</em> that determine the object’s type,
where <em>inheritance</em> can be used to let classes extend from other classes,
and thereby inheriting their fields, methods, and type(s).
Unfortunately, inheritance is often overused in places where <em>composition</em> would be better suited <span class="references">[<a href="#ref-1">1</a>]</span>,
where composition of objects (containment within each other) leads to more flexibility in terms of object relationships,
and thereby leads to more loosely coupled objects.</p>

          <p>A popular technique to manage the composition of objects is called <a property="schema:citation http://purl.org/spar/cito/cites" href="https://martinfowler.com/articles/injection.html"><em>Dependency Injection</em> (DI)</a> <span class="references">[<a href="#ref-2">2</a>]</span>.
It assumes that objects are loosely coupled,
and that they only depend on each other via a minimal and generic interface,
without depending on concrete implementations of such interfaces.
In order to link these interfaces to concrete implementations,
a generic DI framework can provide specific implementations where needed based on some external configuration.
Since objects only communicate by strict interfaces,
and specific implementations are derived from an external configuration,
the specific wiring of a software application is not hard-coded anymore.
Instead, this wiring can be altered afterwards by modifying the configuration file,
which makes the application more flexible.</p>

          <p>Configurations for existing DI frameworks
are either defined directly within a programming language,
or are defined declaratively within text files with a domain-specific language using syntaxes such as JSON and XML.
The latter type of configuration files is better suited for use cases where no changes can be made to existing code –e.g., in the case of pre-compiled languages–,
when the creators of these configuration files have no programming knowledge,
or when configuration files are created automatically from an external tool –e.g., a visual drag-and-drop interface–.
Such declarative configuration files typically have only local semantics,
which means that they are usually only usable within the DI framework for which they were created, and for the current application only.
With the power of <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/DesignIssues/LinkedData.html">Linked Data</a> <span class="references">[<a href="#ref-3">3</a>]</span> and the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www-sop.inria.fr/acacia/cours/essi2006/Scientific%20American_%20Feature%20Article_%20The%20Semantic%20Web_%20May%202001.pdf">Semantic Web</a> <span class="references">[<a href="#ref-4">4</a>]</span> in mind,
these configurations could move <em>beyond</em> their local scope,
and make them globally <em>interoperable</em>, <em>addressable</em>, and <em>discoverable</em>.</p>

          <p>To this end, we present <em>Components.js</em>,
a semantic DI framework for TypeScript and JavaScript applications
that gives global semantics to software configurations, hence surpassing existing dependency injection frameworks.
Components.js thereby enables highly modular applications to be built that are dynamically wired based on semantic configuration files.
The framework is <a href="https://github.com/LinkedSoftwareDependencies/Components.js" class="mandatory" data-link-text="https:/​/​github.com/​LinkedSoftwareDependencies/​Components.js">open-source</a>,
available on <a href="https://www.npmjs.com/package/componentsjs" class="mandatory" data-link-text="https:/​/​www.npmjs.com/​package/​componentsjs">npm</a>,
and its complete documentation can be found at <a href="https://componentsjs.readthedocs.io/" class="mandatory" data-link-text="https:/​/​componentsjs.readthedocs.io/​">https:/​/​componentsjs.readthedocs.io/</a>.
Furthermore, it is being actively used as core technology within popular tools such as
<a href="https://github.com/solid/community-server/" class="mandatory" data-link-text="https:/​/​github.com/​solid/​community-​server/​">Solid Community Server</a> and <a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.github.io/Article-ISWC2018-Resource/">Comunica</a> <span class="references">[<a href="#ref-5">5</a>]</span>.
Within Components.js,
software configurations and modules are described as Linked Data using
the <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://linkedsoftwaredependencies.org/articles/describing-experiments/"><em>Object-Oriented Components vocabulary</em></a> <span class="references">[<a href="#ref-6">6</a>]</span>
and the <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://linkedsoftwaredependencies.org/articles/describing-experiments/"><em>Object Mapping vocabulary</em></a> <span class="references">[<a href="#ref-6">6</a>]</span>.
By publishing such descriptions,
the composition of software (and parts thereof) can be <em>unambiguously identified</em> by IRIs and 
retrieved through <em>dereferencing</em>.
Components.js automatically <em>instantiates</em> such software configurations, including resolving the necessary dependencies.
As such, this (de)referenceability of software configurations by IRI is beneficial in use cases such as:</p>

          <dl>
            <dt>Experimental research</dt>
            <dd>Providing the full provenance trail of used software configurations to produce experimental results and enable reproducibility.</dd>
            <dt>Static program analysis</dt>
            <dd>Discovering conflicts or compatibility issues of different classes within software using RDF tools such as SPARQL query engines and reasoners.</dd>
            <dt>Semantic workflows</dt>
            <dd>Automatic wiring of software using RDF tools to optimally address a specific need.</dd>
          </dl>

          <p>In this article, we introduce the Components.js framework as follows.
In the next section (<a href="#related-work">Section 2</a>), we discuss the related work.
Next, in <a href="#configs">Section 3</a> we explain the declarative configuration files of Components.js,
followed by an architectural overview of the framework itself in <a href="#system">Section 4</a>.
Then, in <a href="#usage">Section 5</a>, we mention some applications where Components.js is being used.
Finally, we conclude in <a href="#conclusions">Section 6</a>.</p>

        </div>
</section>

  <section id="related-work" inlist="" rel="schema:hasPart" resource="#related-work">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Related Work</h2>

          <h3 id="related-work-di">Dependency Injection</h3>

          <p><strong>Inversion of Control</strong></p>

          <p><a property="schema:citation http://purl.org/spar/cito/cites" href="https://martinfowler.com/articles/injection.html">Inversion of Control (IoC)</a> <span class="references">[<a href="#ref-2">2</a>]</span> is a general principle within software engineering
that inverts the usual flow of control within software architectures.
This is mostly done to reduce coupling between software components, and make the overall architecture more modular and extensible.
On the one hand, traditional procedural programming gives the developer direct control of the flow of logic, where code directly invokes other code.
IoC on the other hand implies the use of a framework that manages this flow,
and allows custom code –that is supplied by the developer–
to be invoked when the frameworks deems it necessary.
This concept is typically referred to as <em>“The Hollywood Principle: Don’t call us, we’ll call you”</em>.</p>

          <p>A specific technique to achieve IoC is <a property="schema:citation http://purl.org/spar/cito/cites" href="https://martinfowler.com/articles/injection.html"><em>Dependency Injection</em> (DI)</a> <span class="references">[<a href="#ref-2">2</a>]</span>.
As mentioned before, DI is based on the <em>composition</em> of objects to enable relationships between them (as opposed to <em>inheritance</em>).
These composed objects are tied to each other only by a lightweight interface,
where different implementations may be possible for each interface.
Using a DI framework, specific implementations for such interfaces can be configured,
after which they can be instantiated into objects,
and are injected into each other using the DI framework’s <em>assembler</em> to complete the wiring of the software application.</p>

          <p>The configuration of such a wiring of objects
can either be done in code, or via external configuration files.
The main motivations for configurations are the strict boundaries between configuration and logic,
enabling non-developers to configure the code,
and taking away the need to recompile the code for pre-compiled languages.
However, when dependencies are defined based on some logic such as external conditions,
then configuring via code may be better suited,
as this can become too complex to define in declarative configuration files.</p>

          <p><strong>Forms of Injection</strong></p>

          <p>In practise, three main forms of DI exist through which dependencies can be injected into a an object:</p>

          <dl>
            <dt>Constructor injection</dt>
            <dd>Dependency objects are passed via a class constructor.</dd>
            <dt>Setter injection</dt>
            <dd>Dependencies are passed to an object by invoking setter methods.</dd>
            <dt>Interface injection</dt>
            <dd>The interface of dependencies expose a method that –when invoked– injects this dependency into an object that is passed to it. Such passed objects will typically a setter method for this.</dd>
          </dl>

          <p>Constructor injection is the simplest and most popular form.
It requires all dependencies to be wired at construction time,
which usually leads to immutable wiring.
Setter injection is more flexible as wiring can be changed afterwards,
but could lead to problems where not all dependencies have been fully configured yet.
Interface injection is more complex, and is mainly useful if bidirectional links between dependencies and dependents need to be configured.</p>

          <p><strong>Advantages and Disadvantages</strong></p>

          <p>To end this section, we summarize the main <a href="https://betterprogramming.pub/the-6-benefits-of-dependency-injection-7802b207ec69">advantages</a>
and <a href="https://www.professionalqa.com/dependency-injection">disadvantages</a> of DI.</p>

          <p>Advantages:</p>

          <ul>
            <li>Classes are loosely coupled, which leads to <strong>lower maintenance</strong> effort.</li>
            <li>Loose coupling also leads to better <strong>testability</strong>, as dependencies with lightweight interfaces can easily be mocked.</li>
            <li>Classes have a single responsibility, which leads to <strong>better understandable</strong> code.</li>
            <li>Applications are more <strong>flexible</strong>, as they can be wired differently by changing a configuration file.</li>
            <li>Applications are more <strong>extensible</strong>, as different interface implementations can be created, and swapped in or out easily.</li>
            <li>Since classes are coded against interfaces of dependencies, they lead to more <strong>independent</strong> code, which is beneficial in large teams that work in parallel.</li>
          </ul>

          <p>Disadvantages:</p>

          <ul>
            <li>Defining the wiring of an application via <strong>configurations can be complex</strong>, so good defaults must be available.</li>
            <li>Logic <strong>flow is harder to follow</strong> when debugging, which leads to the need of good documentation.</li>
            <li>DI frameworks can lead to <strong>overhead</strong> in terms of understandability, execution time and software size.</li>
          </ul>

          <h3 id="related-work-software-description">Semantic Software Description</h3>

          <p>Configuration-based DI frameworks make use of some form of software description.
Therefore, we introduce the related work around semantic software descriptions.</p>

          <p>Software can be described on several levels of granularity,
going from a high-level package overview to a low-level description of the actual code.
The Software Ontology (SWO) <span class="references">[<a href="#ref-7">7</a>]</span> and <a property="schema:citation http://purl.org/spar/cito/cites" href="http://usefulinc.com/ns/doap">Description of a Project (DOAP)</a> <span class="references">[<a href="#ref-8">8</a>]</span> ontology focus on the high-level management of software development,
enabling the description of tools, resources, contributors and tasks. 
At a slightly lower level, SWO includes interfaces, algorithms, versions, and the associated provenance data, but does not reach the level of detail to describe operational code.</p>

          <p>Ontologies that describe software configuration from a research workflow perspective are <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1145/2814864.2814882"><a href="http://svn.aksw.org/papers/2015/SEMANTICS_LDWPO/public.pdf">LODFlow</a></span> <span class="references">[<a href="#ref-9">9</a>]</span>, <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2015.01.003"><a href="https://doi.org/10.1016/j.websem.2015.01.003">Workflow-Centric Research Objects</a></span> <span class="references">[<a href="#ref-10">10</a>]</span> with the <cite><a href="https://w3id.org/ro/">Wf4Ever Research Object Model</a></cite> and the <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1109/escience.2014.47"><a href="http://www.ifs.tuwien.ac.at/%7Emayer/publications/pdf/may_escience14.pdf">Ontologies for Describing the Context of Scientific Experiment Processes</a></span> <span class="references">[<a href="#ref-11">11</a>]</span> with the <cite><a href="http://www.timbusproject.net/portal/publications/ontologies/">TIMBUS Context Model</a></cite> to compliment the Research Objects model. 
From a more generic perspective, there exist the <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://www.w3.org/TR/prov-o/">PROV Ontology</a> <span class="references">[<a href="#ref-12">12</a>]</span>, the <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="http://www.opmw.org/model/OPMW/">OPMW-PROV Ontology</a> <span class="references">[<a href="#ref-13">13</a>]</span>, and the <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="http://rdf-vocabulary.ddialliance.org/discovery.html">DDI-RDF Discovery Vocabulary</a> <span class="references">[<a href="#ref-14">14</a>]</span>.
However, these efforts can only cover (parts of) the connection between research and software, which is insufficient for dependency injection.
Such descriptions are however interpretive in that any given tool is subject to having multiple descriptions by different users.
In contrast to the human-driven descriptions, our work both enables and accelerates the generation of machine-driven Linked Data descriptions of software modules, their components, as well as their configurations to be uniformly created.
Consequently, this makes it possible to accurately describe and instantiate software experiments that can be reused and compared with unambiguously.</p>

          <p>Much more low-level and exact is the Core Software Ontology (CSO) <span class="references">[<a href="#ref-15">15</a>]</span>,
which provides a foundational vocabulary that is designed for extensibility.
This includes the distinctive concepts to describe software as code, software as object to computational hardware, and software as a running computational activity,
but also Interfaces, Classes, Methods, the relationships between them, and workflow information on their invocation.
Its extension, the Core Ontology of Software Components (COSC), moves closer to the topic of this article by describing interfaces and protocols of objects.
Similar in scope is the Software Engineering Ontology Network (SEON) <span class="references">[<a href="#ref-16">16</a>]</span>, which consolidates multiple ontologies for the Software Engineering field.
It includes a higher Core and Foundational layer, as well as multiple domain-specific ontologies.
Of particular interest is their Software Ontology (SwO) that captures the different artifacts in software.
In general, both ontologies (or suites) view software from a <q>network of communicating concepts</q> perspective.
This allows for exhaustive descriptions of complex software systems, but is not suited for describing class instances or aspects of modular programming (e.g., package dependencies).</p>

          <h3 id="related-work-di-frameworks">Dependency Injection Frameworks</h3>

          <p>The large spectrum of existing dependency injection frameworks indicates a high demand for such systems.
Java likely contains the largest collection of dependency injection frameworks.
Much of this stems from the strict typing,
which makes it difficult to create mock objects when required for testing
if the dependencies are nested in the implementation.</p>

          <p>One of the biggest Java frameworks is <a href="https://spring.io/">Spring</a>,
which amongst many things, also provides dependency injection.
That is one of its advantages though:
many projects already use Spring for other reasons,
reducing the jump required to add the dependency injection framework.
It supports two ways to do the injection.
The first one is through an external XML configuration file
which defines all the classes and how they are linked together.
The other one is with annotations in the actual code
that define how the interlinking of classes should work.
Google’s <a href="https://github.com/google/guice">Guice</a> is a more lightweight alternative to Spring;
<a href="https://github.com/google/dagger">Dagger</a> was created to be even more lightweight than Guice.</p>

          <p>In JavaScript, 
dependency injection frameworks tend to be less common because of its flexible nature.
Still, multiple frameworks are available, such as <a href="https://github.com/young-steveo/bottlejs">BottleJS</a>, <a href="https://github.com/cujojs/wire">Wire</a>, and <a href="https://github.com/jaredhanson/electrolyte">Electrolyte</a>, all backed by rather small communities.
One of the biggest ones, <a href="https://github.com/inversify/InversifyJS">InversifyJS</a>,
uses annotations similar to Java frameworks to define possible injections.
Unlike standard JavaScript,
it requires you to define interfaces and types via TypeScript,
thereby allowing it to make use of this extra information to correctly handle the linking.
Like Guice, it also has a bindings file to link classes to interfaces.</p>

          <p>Components.js differs from most of the aforementioned frameworks on different aspects,
of which the first one is unique to Components.js:</p>

          <ul>
            <li>RDF-based configuration files in order to make them globally <em>interoperable</em>, <em>addressable</em>, and <em>discoverable</em>.</li>
            <li>Decoupling of the dependency injection layer from the software implementation.</li>
          </ul>

        </div>
</section>

  <section id="configs" inlist="" rel="schema:hasPart" resource="#configs">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Declarative Configurations</h2>

          <p>Components.js depends on two levels of configuration for enabling the wiring of software components.
The first level is the creation of <em>components</em> files,
which are the semantic representation of component constructors,
and can usually be automatically generated.
The second level is the creation of <em>configuration</em> files,
which represent the actual instantiation of components
based on the generated components files.
Hereafter, we explain these two levels in more detail.</p>

          <h3 id="components-files">Components files</h3>

          <p>Component files are used to semantically represent the constructors of software components.
For this, we make use of two vocabularies, which will be explained hereafter.
Next, we explain how URLs can be minted for software components, so that they become fully dereferenceable.
Finally, we explain how these component files can be generated automatically from existing TypeScript code.</p>

          <h4 id="object-oriented-components-vocabulary">Object-Oriented Components Vocabulary</h4>

          <p>Components.js distinguishes between three main concepts:</p>

          <dl>
            <dt>Module</dt>
            <dd>a software package containing zero or more components. This is equivalent to a Node module or npm package.</dd>
            <dt>Component</dt>
            <dd>a class that can be instantiated by creating a new instance of that type with zero or more parameter values. Parameters are defined by the class constructor.</dd>
            <dt>Configuration</dt>
            <dd>a semantic representation of an instantiation of a component into an object instance based on parameters.</dd>
          </dl>

          <p>These concepts are described in the programming language independent <a href="https://linkedsoftwaredependencies.org/vocabularies/object-oriented"><em>Object-Oriented Components vocabulary (OO)</em></a> <span class="references">[<a href="#ref-6">6</a>]</span>.
This vocabulary enables software components to be instantiated based on certain parameters,
analog to constructor arguments in object-oriented programming.
This is interpreted in the broad sense: only <em>classes</em>, <em>objects</em> and <em>constructor parameters</em> are considered.
An overview is given in <a href="#voc-oo-diagram">Fig. 1</a>.</p>

          <figure id="voc-oo-diagram">
<img src="img/voc-oo-diagram.svg" alt="[description diagram]" />
<figcaption>
              <p><span class="label">Fig. 1:</span> Classes and properties in the <a href="https://linkedsoftwaredependencies.org/vocabularies/object-oriented"><em>Object-Oriented Components vocabulary (OO)</em></a>, with as prefix <code>oo</code>.</p>
            </figcaption>
</figure>

          <p>A module is considered a collection of components.
Within object-oriented languages, this can correspond to for example a software library or an application.
A component is typed as <code>oo:Component</code>, which is a <em>subclass</em> of <code>rdfs:Class</code>.
The parameters to construct the component can therefore be defined as an <code>rdfs:Property</code> on a component.</p>

          <figure id="module-oo" class="listing">
<pre><code>{
</code><code>  &quot;@context&quot;: [
</code><code>    &quot;https://linkedsoftwaredependencies.org/bundles/npm/componentsjs/
</code><code>      ^4.0.0/components/context.jsonld&quot;,
</code><code>    { &quot;ex&quot;: &quot;http://example.org/&quot; }
</code><code>  ],
</code><code>  &quot;@id&quot;: &quot;ex:MyModule&quot;,
</code><code>  &quot;@type&quot;: &quot;Module&quot;,
</code><code>  &quot;requireName&quot;: &quot;my-module&quot;,
</code><code>  &quot;components&quot;: [
</code><code>    {
</code><code>      &quot;@id&quot;: &quot;ex:MyModule/MyComponent&quot;,
</code><code>      &quot;@type&quot;: &quot;Class&quot;,
</code><code>      &quot;requireElement&quot;: &quot;MyComponent&quot;,
</code><code>      &quot;parameters&quot;: [
</code><code>        {
</code><code>          &quot;@id&quot;: &quot;ex:MyModule/MyComponent#name&quot;,
</code><code>          &quot;unique&quot;: true,
</code><code>          &quot;range&quot;: &quot;xsd:string&quot;
</code><code>        }
</code><code>      ]
</code><code>    }
</code><code>  ]
</code><code>}</code></pre>
<figcaption>
              <p><span class="label">Listing 1:</span> A description of a module <code>ex:MyModule</code> with a single component using the JSON-LD serialization,
compacted with the <code>https:/​/​linkedsoftwaredependencies.org/bundles/npm/componentsjs/^4.0.0/components/context.jsonld</code> context.</p>
            </figcaption>
</figure>

          <p>We illustrate the usage of this vocabulary with an example in <a href="#module-oo">Listing 1</a> using the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/json-ld/">JSON-LD</a> <span class="references">[<a href="#ref-17">17</a>]</span> serialization.
This listing shows the definition of a new module (<code>oo:Module</code>) with compact IRI <code>ex:MyModule</code>.
The name of the module is set with the compact IRI <code>requireName</code>, which expands to <code>doap:name</code> from the <a href="https://github.com/ewilderj/doap/wiki">Description of a Project (DOAP) vocabulary</a>.
Furthermore, our module contains a single class component (<code>oo:Class</code>) with compact IRI <code>ex:MyModule/MyComponent</code>.
Since this is a class component (subclass of <code>oo:Component</code>), this means that this components is instantiatable based on parameters.
Each component can refer to its path within a module using the <code>oo:componentPath</code> predicate (compacted as <code>requireElement</code>).
Finally, our single component has a parameter (<code>oo:Parameter</code>) with compact IRI <code>ex:MyModule/MyComponent#name</code>
that can be set when instantiating this component.</p>

          <p>Since components and parameters are defined as RDFS vocabulary,
we can instantiate components easily using the <code>rdf:type</code> predicate,
and by using parameters as predicates on such new instances, as shown in <a href="#instance-oo">Listing 2</a>.
Instead of passing literals as values to parameters, it is also possible to pass <em>other component instances</em> as values,
thereby allowing nested component instantiations to be defined.</p>

          <figure id="instance-oo" class="listing">
<pre><code>{
</code><code>  &quot;@context&quot;: [
</code><code>    &quot;https://linkedsoftwaredependencies.org/bundles/npm/componentsjs/
</code><code>      ^4.0.0/components/context.jsonld&quot;,
</code><code>    { &quot;ex&quot;: &quot;http://example.org/&quot; }
</code><code>  ],
</code><code>  &quot;@type&quot;: &quot;ex:MyModule/MyComponent&quot;,
</code><code>  &quot;ex:MyModule/MyComponent#name&quot;: &quot;Some name&quot;
</code><code>}</code></pre>
<figcaption>
              <p><span class="label">Listing 2:</span> Instantiation of <code>ex:MyModule/MyComponent</code> using a value for the parameter <code>ex:MyModule/MyComponent#name</code>.</p>
            </figcaption>
</figure>

          <h4 id="object-mapping-vocabulary">Object Mapping Vocabulary</h4>

          <p>As shown in the previous section, the OO vocabulary allows modules, components, and parameters to be defined,
so that instances of components can be declared.
However, this vocabulary only defines parameter values for component instances,
but it does not define how these parameter values are used to invoke the constructor of this component.
To enable this, we introduce the accompanying <a href="https://linkedsoftwaredependencies.org/vocabularies/object-mapping" class="mandatory" data-link-text="https:/​/​linkedsoftwaredependencies.org/​vocabularies/​object-​mapping"><em>Object Mapping vocabulary (OM)</em></a>.
<a href="#voc-om-diagram">Fig. 2</a> shows an overview of all its classes and predicates.</p>

          <figure id="voc-om-diagram">
<img src="img/voc-om-diagram.svg" alt="[Object Mapping vocabulary diagram]" />
<figcaption>
              <p><span class="label">Fig. 2:</span> Classes and properties in the <a href="https://linkedsoftwaredependencies.org/vocabularies/object-mapping#"><em>Object Mapping</em> vocabulary</a>, with as prefix <code>om</code>.</p>
            </figcaption>
</figure>

          <p>The OM vocabulary makes use of the <code>oo:constructorArguments</code> predicate for the domain <code>oo:Class</code>,
and thereby builds upon the OO vocabulary via the <code>oo:constructorArguments</code> extension point to define the class constructor’s behaviour.
Concretely, this new vocabulary defines a mapping between the component parameters as defined using the OO vocabulary,
and the raw objects that are passed into the constructor during instantiation.</p>

          <p>In essence, this vocabulary enables an (RDF list) of <code>om:ObjectMapping</code>’s to be passed to the <code>oo:constructorArguments</code> of an <code>oo:Class</code>.
An <code>om:ObjectMapping</code> represents an object containing zero or more key-value pairs, which are represented by <code>om:ObjectMappingEntry</code>.
<code>om:ArrayMapping</code> is a special type of <code>om:ObjectMapping</code> that represents an array, where its elements can be other <code>om:ObjectMapping</code>’s.</p>

          <figure id="module-om" class="listing">
<pre><code>{
</code><code>  &quot;@context&quot;: [
</code><code>    &quot;https://linkedsoftwaredependencies.org/bundles/npm/componentsjs/
</code><code>      ^4.0.0/components/context.jsonld&quot;,
</code><code>    { &quot;ex&quot;: &quot;http://example.org/&quot; }
</code><code>  ],
</code><code>  &quot;@id&quot;: &quot;ex:MyModule&quot;,
</code><code>  &quot;@type&quot;: &quot;Module&quot;,
</code><code>  &quot;requireName&quot;: &quot;my-module&quot;,
</code><code>  &quot;components&quot;: [
</code><code>    {
</code><code>      &quot;@id&quot;: &quot;ex:MyModule/MyComponent&quot;,
</code><code>      &quot;@type&quot;: &quot;Class&quot;,
</code><code>      &quot;requireElement&quot;: &quot;MyComponent&quot;,
</code><code>      &quot;parameters&quot;: [
</code><code>        {
</code><code>          &quot;@id&quot;: &quot;ex:MyModule/MyComponent#name&quot;,
</code><code>          &quot;unique&quot;: true,
</code><code>          &quot;range&quot;: &quot;xsd:string&quot;
</code><code>        }
</code><code>      ]
</code><code>    }
</code><code>  ],
</code><code>  &quot;constructorArguments&quot;: [
</code><code>    {
</code><code>      &quot;fields&quot;: [
</code><code>        {
</code><code>          &quot;keyRaw&quot;: &quot;name&quot;,
</code><code>          &quot;value&quot;: &quot;ex:MyModule/MyComponent#name&quot;
</code><code>        }
</code><code>      ]
</code><code>    }
</code><code>  ]
</code><code>}</code></pre>
<figcaption>
              <p><span class="label">Listing 3:</span> A description of a module <code>ex:MyModule</code> with a single component having constructor arguments using the JSON-LD serialization,
compacted with the <code>https:/​/​linkedsoftwaredependencies.org/bundles/npm/componentsjs/^4.0.0/components/context.jsonld</code> context.</p>
            </figcaption>
</figure>

          <p>Building upon the OO example from <a href="#module-om">Listing 3</a>, we illustrate the usage of this vocabulary with an example in <a href="#module-om">Listing 3</a>, again using the JSON-LD serialization.
The only difference with the previous example, is the addition of the <code>constructorArguments</code> block,
which expands to <code>oo:constructorArguments</code> that is configured to always contain an RDF list.
The constructor arguments contain a single <code>om:ObjectMapping</code>, which is implied by the presence of <code>field</code>, which expands to <code>om:field</code>.
Since the field array contains just a single element (<code>om:ObjectMappingEntry</code>),
it represents an object with a single key and value.
The key is defined by <code>keyRaw</code> (expands to <code>om:fieldName</code>), which contains the constant <code>name</code>.
The value is defined by <code>value</code> (expands to <code>om:fieldValue</code>), which refers to the <code>ex:MyModule/MyComponent#name</code> parameter.</p>

          <p>The addition of an object mapping to a component requires no changes as to how a component is instantiated,
which means that our component from <a href="#module-om">Listing 3</a> can still be instantiated in the exact same way as the one from <a href="#module-oo">Listing 1</a>.
The only difference now, is that we are able to determine how exactly the parameter values are to be used for invoking the component constructor.
For example, the instantiation of <a href="#instance-oo">Listing 2</a> corresponds to the following code in JavaScript: <code>new MyComponent({ name: 'Some name' })</code></p>

          <h4 id="dereferenceability">Dereferenceability</h4>

          <p class="todo">Write me: via LSD</p>

          <h4 id="generation-from-typescript">Generation from TypeScript</h4>

          <p class="todo">Write me</p>

          <h3 id="configuration-files">Configuration files</h3>

          <p class="todo">Write me</p>

        </div>
</section>

  <section id="system" inlist="" rel="schema:hasPart" resource="#system">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Dependency Injection Framework</h2>

          <p class="todo">Write me: with emphasis on quality! (unit tests and docs)
Also explain how instantiation is done (also fallback if no constructor args are passed)</p>

        </div>
</section>

  <section id="usage" inlist="" rel="schema:hasPart" resource="#usage">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Usage</h2>

          <p class="todo">Write me: Direct and indirect dependents (within and outside or own tools); Downloads</p>

        </div>
</section>

  <section id="conclusions" inlist="" rel="schema:hasPart" resource="#conclusions">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Conclusions</h2>

          <p class="todo">Write me: in what cases it’s useful (and when not), and future work</p>

        </div>
</section>

</main>

<footer><section>
<h2 id="references">References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="#designpatterns" typeof="schema:Article">Gamma, E., Helm, R., Johnson, R., Vlissides, J., Patterns, D.: Elements of Reusable Object-Oriented Software. Design Patterns. massachusetts: Addison-Wesley Publishing Company. (1995).</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="https://martinfowler.com/articles/injection.html" typeof="schema:CreativeWork">Fowler, M.: Inversion of Control Containers and the Dependency Injection pattern. <a href="https://martinfowler.com/articles/injection.html">https:/​/​martinfowler.com/articles/injection.html</a> (2004).</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="https://www.w3.org/DesignIssues/LinkedData.html" typeof="schema:CreativeWork">Berners-Lee, T.: Linked Data. <a href="https://www.w3.org/DesignIssues/LinkedData.html">https:/​/​www.w3.org/DesignIssues/LinkedData.html</a> (2006).</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="https://www-sop.inria.fr/acacia/cours/essi2006/Scientific%20American_%20Feature%20Article_%20The%20Semantic%20Web_%20May%202001.pdf" typeof="schema:Article">Berners-Lee, T., Hendler, J., Lassila, O., others: The Semantic Web. Scientific American. 284, 28–37 (2001).</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="https://comunica.github.io/Article-ISWC2018-Resource/" typeof="schema:Article">Taelman, R., Van Herwegen, J., Vander Sande, M., Verborgh, R.: Comunica: a Modular SPARQL Query Engine for the Web. In: Proceedings of the 17th International Semantic Web Conference (2018).</dd>
  <dt id="ref-6">[6]</dt>
  <dd resource="https://linkedsoftwaredependencies.org/articles/describing-experiments/" typeof="schema:Article">Van Herwegen, J., Taelman, R., Capadisli, S., Verborgh, R.: Describing configurations of software experiments as Linked Data. In: Proceedings of the 1st SemSci Workshop (2017).</dd>
  <dt id="ref-7">[7]</dt>
  <dd resource="#malone2014software" typeof="schema:Article">Malone, J., Brown, A., Lister, A.L., Ison, J., Hull, D., Parkinson, H., Stevens, R.: The Software Ontology (SWO): a resource for reproducibility in biomedical data analysis, curation and digital preservation. Journal of biomedical semantics. 5, 25 (2014).</dd>
  <dt id="ref-8">[8]</dt>
  <dd resource="http://usefulinc.com/ns/doap" typeof="schema:CreativeWork">Wilder-James, E.: Description of a Project. <a href="http://usefulinc.com/ns/doap">http:/​/​usefulinc.com/ns/doap</a> (2017).</dd>
  <dt id="ref-9">[9]</dt>
  <dd resource="https://dx.doi.org/10.1145/2814864.2814882" typeof="schema:Article">Rautenberg, S., Ermilov, I., Marx, E., Auer, S., Ngonga Ngomo, A.-C.: LODFlow: A Workflow Management System for Linked Data Processing. In: Proceedings of the 11th International Conference on Semantic Systems. pp. 137–144. ACM (2015).</dd>
  <dt id="ref-10">[10]</dt>
  <dd resource="https://dx.doi.org/10.1016/j.websem.2015.01.003" typeof="schema:Article">Belhajjame, K., Zhao, J., Garijo, D., Gamble, M., Hettne, K., Palma, R., Mina, E., Corcho, O., Gómez-Pérez, J.M., Bechhofer, S., Klyne, G., Goble, C.: Using a suite of ontologies for preserving workflow-centric research objects. Web Semantics: Science,  Services and Agents on the World Wide Web. 32, 16–42 (2015).</dd>
  <dt id="ref-11">[11]</dt>
  <dd resource="https://dx.doi.org/10.1109/escience.2014.47" typeof="schema:Article">Mayer, R., Miksa, T., Rauber, A.: Ontologies for Describing the Context of Scientific Experiment Processes. In: 10th International Conference on e-Science. IEEE (2014).</dd>
  <dt id="ref-12">[12]</dt>
  <dd resource="https://www.w3.org/TR/prov-o/" typeof="schema:CreativeWork">Lebo, T., Sahoo, S., McGuinness, D.: Prov-O: The PROV Ontology. W3C, <a href="https://www.w3.org/TR/prov-o/">https:/​/​www.w3.org/TR/prov-o/</a> (2013).</dd>
  <dt id="ref-13">[13]</dt>
  <dd resource="http://www.opmw.org/model/OPMW/" typeof="schema:CreativeWork">Garijo, D., Gil, Y.: OPMW-PROV Ontology. <a href="http://www.opmw.org/model/OPMW/">http:/​/​www.opmw.org/model/OPMW/</a> (2014).</dd>
  <dt id="ref-14">[14]</dt>
  <dd resource="http://rdf-vocabulary.ddialliance.org/discovery.html" typeof="schema:CreativeWork">Bosch, T., Cyganiak, R., Wackerow, J., Zapilko, B.: DDI-RDF Discovery Vocabulary. <a href="http://rdf-vocabulary.ddialliance.org/discovery.html">http:/​/​rdf-vocabulary.ddialliance.org/discovery.html</a> (2015).</dd>
  <dt id="ref-15">[15]</dt>
  <dd resource="#oberle2009ontology" typeof="schema:Chapter">Oberle, D., Grimm, S., Staab, S.: An ontology for software. In: Handbook on ontologies. pp. 383–402. Springer (2009).</dd>
  <dt id="ref-16">[16]</dt>
  <dd resource="#ruy2016seon" typeof="schema:Article">Ruy, F.B., de Almeida Falbo, R., Barcellos, M.P., Costa, S.D., Guizzardi, G.: SEON: A software engineering ontology network. In: European Knowledge Acquisition Workshop. pp. 527–542. Springer (2016).</dd>
  <dt id="ref-17">[17]</dt>
  <dd resource="https://www.w3.org/TR/json-ld/" typeof="schema:CreativeWork">JSON-LD 1.1: a JSON-based serialization for linked data. <a href="https://www.w3.org/TR/json-ld/">https:/​/​www.w3.org/TR/json-ld/</a></dd>
</dl>
</section>
</footer>

</div>
</div>



</body>
</html>
